

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="韩启川">
  <meta name="keywords" content="">
  
    <meta name="description" content="官网访问mysql 官网：https:&#x2F;&#x2F;www.mysql.com&#x2F; DOCUMENTATION  -&gt; MySQL Reference Manual 优化：Optimization 参数：  MySQL Server Administration &#x2F; The MySQL Server 什么是mysql优化mysql优化在软件开发的整个周期中。 1.mysql安装前的主机选购(C">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql优化">
<meta property="og:url" content="http://hanqichuan.com/2022/05/18/mysql/mysql%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="这是一个很酷的事">
<meta property="og:description" content="官网访问mysql 官网：https:&#x2F;&#x2F;www.mysql.com&#x2F; DOCUMENTATION  -&gt; MySQL Reference Manual 优化：Optimization 参数：  MySQL Server Administration &#x2F; The MySQL Server 什么是mysql优化mysql优化在软件开发的整个周期中。 1.mysql安装前的主机选购(C">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hanqichuan.com/.com//%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%AF%B9%E6%AF%94.png">
<meta property="og:image" content="http://hanqichuan.com/.com//performanceschema%E9%85%8D%E7%BD%AE%E8%A1%A8.png">
<meta property="og:image" content="http://hanqichuan.com/.com//simpleNestedLoopJoin.png">
<meta property="og:image" content="http://hanqichuan.com/.com//indexNestedLoopJoin.png">
<meta property="og:image" content="http://hanqichuan.com/.com//blockNestedLoopJoin.png">
<meta property="og:image" content="http://hanqichuan.com/.com//%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E6%83%85%E5%86%B5.png">
<meta property="article:published_time" content="2022-05-18T06:31:12.000Z">
<meta property="article:modified_time" content="2022-07-09T07:34:15.436Z">
<meta property="article:author" content="韩启川">
<meta property="article:tag" content="mysql">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://hanqichuan.com/.com//%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%AF%B9%E6%AF%94.png">
  
  
  <title>mysql优化 - 这是一个很酷的事</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"hanqichuan.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>这是一件很酷的事</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="mysql优化">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-05-18 14:31" pubdate>
        2022年5月18日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      56k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      467 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">mysql优化</h1>
            
            <div class="markdown-body">
              <h1 id="官网访问"><a href="#官网访问" class="headerlink" title="官网访问"></a>官网访问</h1><p>mysql 官网：<a target="_blank" rel="noopener" href="https://www.mysql.com/">https://www.mysql.com/</a></p>
<p>DOCUMENTATION  -&gt; <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/en/">MySQL Reference Manual</a></p>
<p>优化：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/optimization.html">Optimization</a></p>
<p>参数：  <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/server-administration.html">MySQL Server Administration</a> &#x2F; <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/mysqld-server.html">The MySQL Server</a></p>
<h1 id="什么是mysql优化"><a href="#什么是mysql优化" class="headerlink" title="什么是mysql优化"></a>什么是mysql优化</h1><p>mysql优化在软件开发的整个周期中。</p>
<p>1.mysql安装前的主机选购(CPU、内存、磁盘、带宽)，mysql安装时的参数配置</p>
<p>2.使用存储引擎、表、字段</p>
<p>3.监控、压测(CPU、内存、磁盘、带宽)（sql响应时间）</p>
<p>​	mysql配置参数的优化</p>
<p>​	sql优化	</p>
<h1 id="mysql参数"><a href="#mysql参数" class="headerlink" title="mysql参数"></a>mysql参数</h1><p>show variables like ‘%xxx%’ </p>
<p>列一些参数，不全</p>
<p>general</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>datadir&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql</td>
<td>数据文件存放的目录</td>
</tr>
<tr>
<td>socket&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql.sock</td>
<td>mysql.socket表示server和client在同一台服务器，并且使用localhost进行连接，就会使用socket进行连接</td>
</tr>
<tr>
<td>pid_file&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql.pid</td>
<td>存储mysql的pid</td>
</tr>
<tr>
<td>port&#x3D;3306</td>
<td>mysql服务的端口号</td>
</tr>
<tr>
<td>default_storage_engine&#x3D;InnoDB</td>
<td>mysql默认存储引擎</td>
</tr>
<tr>
<td>skip-grant-tables</td>
<td>当忘记mysql的用户名密码的时候，可以在mysql配置文件中配置该参数，跳过权限表验证，不需要密码即可登录mysql</td>
</tr>
</tbody></table>
<p>character</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>character_set_client</td>
<td>客户端数据的字符集</td>
</tr>
<tr>
<td>character_set_connection</td>
<td>mysql处理客户端发来的信息时，会把这些数据转换成连接的字符集格式</td>
</tr>
<tr>
<td>character_set_results</td>
<td>mysql发送给客户端的结果集所用的字符集</td>
</tr>
<tr>
<td>character_set_database</td>
<td>数据库默认的字符集</td>
</tr>
<tr>
<td>character_set_server</td>
<td>mysql server的默认字符集</td>
</tr>
</tbody></table>
<p>connection</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>max_connections</td>
<td>mysql的最大连接数，如果数据库的并发连接请求比较大，应该调高该值</td>
</tr>
<tr>
<td>max_user_connections</td>
<td>限制每个用户的连接个数</td>
</tr>
<tr>
<td>back_log</td>
<td>mysql能够暂存的连接数量，当mysql的线程在一个很短时间内得到非常多的连接请求时，就会起作用，如果mysql的连接数量达到max_connections时，新的请求会被存储在堆栈中，以等待某一个连接释放资源，如果等待连接的数量超过back_log,则不再接受连接资源</td>
</tr>
<tr>
<td>wait_timeout</td>
<td>mysql在关闭一个非交互的连接之前需要等待的时长</td>
</tr>
<tr>
<td>interactive_timeout</td>
<td>关闭一个交互连接之前需要等待的秒数</td>
</tr>
</tbody></table>
<p>log</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>log_error</td>
<td>指定错误日志文件名称，用于记录当mysqld启动和停止时，以及服务器在运行中发生任何严重错误时的相关信息</td>
</tr>
<tr>
<td>log_bin</td>
<td>指定二进制日志文件名称，用于记录对数据造成更改的所有查询语句</td>
</tr>
<tr>
<td>binlog_do_db</td>
<td>指定将更新记录到二进制日志的数据库，其他所有没有显式指定的数据库更新将忽略，不记录在日志中</td>
</tr>
<tr>
<td>binlog_ignore_db</td>
<td>指定不将更新记录到二进制日志的数据库</td>
</tr>
<tr>
<td>sync_binlog</td>
<td>指定多少次写日志后同步磁盘</td>
</tr>
<tr>
<td>general_log</td>
<td>是否开启查询日志记录</td>
</tr>
<tr>
<td>general_log_file</td>
<td>指定查询日志文件名，用于记录所有的查询语句</td>
</tr>
<tr>
<td>slow_query_log</td>
<td>是否开启慢查询日志记录</td>
</tr>
<tr>
<td>slow_query_log_file</td>
<td>指定慢查询日志文件名称，用于记录耗时比较长的查询语句</td>
</tr>
<tr>
<td>long_query_time</td>
<td>设置慢查询的时间，超过这个时间的查询语句才会记录日志</td>
</tr>
<tr>
<td>log_slow_admin_statements</td>
<td>是否将管理语句写入慢查询日志</td>
</tr>
</tbody></table>
<p>cache</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>key_buffer_size</td>
<td>索引缓存区的大小（只对myisam表起作用）</td>
</tr>
<tr>
<td>query cache</td>
<td></td>
</tr>
<tr>
<td>query_cache_size</td>
<td>查询缓存的大小，未来版本被删除</td>
</tr>
<tr>
<td></td>
<td>show status like ‘%Qcache%’;查看缓存的相关属性</td>
</tr>
<tr>
<td></td>
<td>Qcache_free_blocks：缓存中相邻内存块的个数，如果值比较大，那么查询缓存中碎片比较多</td>
</tr>
<tr>
<td></td>
<td>Qcache_free_memory：查询缓存中剩余的内存大小</td>
</tr>
<tr>
<td></td>
<td>Qcache_hits：表示有多少此命中缓存</td>
</tr>
<tr>
<td></td>
<td>Qcache_inserts：表示多少次未命中而插入</td>
</tr>
<tr>
<td></td>
<td>Qcache_lowmen_prunes：多少条query因为内存不足而被移除cache</td>
</tr>
<tr>
<td></td>
<td>Qcache_queries_in_cache：当前cache中缓存的query数量</td>
</tr>
<tr>
<td></td>
<td>Qcache_total_blocks：当前cache中block的数量</td>
</tr>
<tr>
<td>query_cache_limit</td>
<td>超出此大小的查询将不被缓存</td>
</tr>
<tr>
<td>query_cache_min_res_unit</td>
<td>缓存块最小大小</td>
</tr>
<tr>
<td>query_cache_type</td>
<td>缓存类型，决定缓存什么样的查询 <br>0表示禁用<br>1表示将缓存所有结果，除非sql语句中使用sql_no_cache禁用查询缓存<br>2表示只缓存select语句中通过sql_cache指定需要缓存的查询</td>
</tr>
<tr>
<td>sort_buffer_size</td>
<td>每个需要排序的线程分派该大小的缓冲区</td>
</tr>
<tr>
<td>max_allowed_packet&#x3D;32M</td>
<td>限制server接受的数据包大小</td>
</tr>
<tr>
<td>join_buffer_size&#x3D;2M</td>
<td>表示关联缓存的大小</td>
</tr>
<tr>
<td>thread_cache_size</td>
<td>Threads_cached：代表当前此时此刻线程缓存中有多少空闲线程<br>Threads_connected：代表当前已建立连接的数量<br>Threads_created：代表最近一次服务启动，已创建现成的数量，如果该值比较大，那么服务器会一直再创建线程<br>Threads_running：代表当前激活的线程数</td>
</tr>
</tbody></table>
<p>INNODB</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>innodb_buffer_pool_size&#x3D;</td>
<td>该参数指定大小的内存来缓冲数据和索引，最大可以设置为物理内存的80%</td>
</tr>
<tr>
<td>innodb_flush_log_at_trx_commit</td>
<td>主要控制innodb将log buffer中的数据写入日志文件并flush磁盘的时间点，值分别为0，1，2</td>
</tr>
<tr>
<td>innodb_thread_concurrency</td>
<td>设置innodb线程的并发数，默认为0表示不受限制，如果要设置建议跟服务器的cpu核心数一致或者是cpu核心数的两倍</td>
</tr>
<tr>
<td>innodb_log_buffer_size</td>
<td>此参数确定日志文件所用的内存大小，以M为单位</td>
</tr>
<tr>
<td>innodb_log_file_size</td>
<td>此参数确定数据日志文件的大小，以M为单位</td>
</tr>
<tr>
<td>innodb_log_files_in_group</td>
<td>以循环方式将日志文件写到多个文件中</td>
</tr>
<tr>
<td>read_buffer_size</td>
<td>mysql读入缓冲区大小，对表进行顺序扫描的请求将分配到一个读入缓冲区</td>
</tr>
<tr>
<td>read_rnd_buffer_size</td>
<td>mysql随机读的缓冲区大小</td>
</tr>
<tr>
<td>innodb_file_per_table</td>
<td>此参数确定为每张表分配一个新的文件</td>
</tr>
</tbody></table>
<h1 id="存储引擎对比"><a href="#存储引擎对比" class="headerlink" title="存储引擎对比"></a>存储引擎对比</h1><p><img src="/.com//%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%AF%B9%E6%AF%94.png" srcset="/img/loading.gif" lazyload alt="存储引擎对比"></p>
<p>聚簇索引：主键索引节点上有对应的一行数据。</p>
<p>非聚簇索引：主键索引节点上只有地址。</p>
<h1 id="字符集的选择"><a href="#字符集的选择" class="headerlink" title="字符集的选择"></a>字符集的选择</h1><p>字符集直接决定了数据在MySQL中的存储编码方式，由于同样的内容使用不同字符集表示所占用的空间大小会有较大的差异，所以通过使用合适的字符集，可以帮助我们尽可能减少数据量，进而减少IO操作次数。</p>
<p>1.纯拉丁字符能表示的内容，没必要选择 latin1 之外的其他字符编码，因为这会节省大量的存储空间。</p>
<p>2.如果我们可以确定不需要存放多种语言，就没必要非得使用UTF8或者其他UNICODE字符类型，这回造成大量的存储空间浪费。</p>
<p>3.MySQL的数据类型可以精确到字段，所以当我们需要大型数据库中存放多字节数据的时候，可以通过对不同表不同字段使用不同的数据类型来较大程度减小数据存储量，进而降低 IO 操作次数并提高缓存命中率。</p>
<h1 id="主键的选择"><a href="#主键的选择" class="headerlink" title="主键的选择"></a>主键的选择</h1><p>自增主键：</p>
<p>与业务无关的，无意义的数字序列。</p>
<p>业务主键：</p>
<p>事物属性中的自然唯一标识。</p>
<p>推荐使用自增主键：</p>
<p>​	它们不与业务耦合，因此更容易维护</p>
<p>​	一个大多数表，最好是全部表，通用的键策略能够减少需要编写的源码数量，减少系统的总体拥有成本。(ID生成器)</p>
<p>​	性能：自增主键一般是顺序插入。</p>
<p>​	存储：一般是数字，存储空间小。</p>
<h1 id="范式与反范式"><a href="#范式与反范式" class="headerlink" title="范式与反范式"></a>范式与反范式</h1><p>第一范式：每个列都不可以再拆分。</p>
<p>地址：河北省保定市     省：河北省  市：保定市</p>
<p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p>
<p>确保 表中 的 每列 和 主键 相关。</p>
<p>学生表：id、学号，姓，名，班级号，学生在班级号中的序号，性别，班主任名称，年龄，是否成年，身份证号。</p>
<p>这里班主任名称和id无关。</p>
<p>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p>
<p>学生表：id、学号，姓，名，班级号，学生在班级号中的序号，性别，班主任名称，年龄，是否成年，身份证号。</p>
<p>这里”是否成年”字段依赖”年龄”字段</p>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>优点：</p>
<p>1.范式化的更新通常比反范式要快；</p>
<p>2.当数据较好的范式化后，很少或者没有重复的数据；</p>
<p>3.范式化的数据比较小，可以放在内存中，操作比较快；</p>
<p>缺点：</p>
<p>通常需要进行关联</p>
<h2 id="反范式"><a href="#反范式" class="headerlink" title="反范式"></a>反范式</h2><p>优点：</p>
<p>1.所有的数据都在同一张表中，可以避免关联；</p>
<p>2.可以设计有效的索引；</p>
<p>缺点：</p>
<p>表格内的冗余较多，删除数据时候会造成表有些有用的信息丢失</p>
<p>在企业中很好能做到严格意义上的范式或者反范式，一般需要混合使用：</p>
<p>1.在一个网站实例中，这个网站，允许用户发送消息，并且一些用户是付费用户。现在想查看付费用户最近的10条信息。  在user表和message表中都存储用户类型(account_type)而不用完全的反范式化。这避免了完全反范式化的插入和删除问题，因为即使没有消息的时候也绝不会丢失用户的信息。这样也不会把user_message表搞得太大，有利于高效地获取数据。</p>
<p>2.另一个从父表冗余一些数据到子表的理由是排序的需要。</p>
<p>3.缓存衍生值也是有用的。如果需要显示每个用户发了多少消息（类似论坛的），可以每次执行一个昂贵的自查询来计算并显示它；也可以在user表中建一个num_messages列，每当用户发新消息时更新这个值。</p>
<h1 id="适当拆分"><a href="#适当拆分" class="headerlink" title="适当拆分"></a>适当拆分</h1><p>当我们的表中存在类似于 TEXT 或者是很大的 VARCHAR类型的大字段的时候，如果我们大部分访问这张表的时候都不需要这个字段，我们就该义无反顾的将其拆分到另外的独立表中，以减少常用数据所占用的存储空间。这样做的一个明显好处就是每个数据块中可以存储的数据条数可以大大增加，既减少物理 IO 次数，也能大大提高内存中的缓存命中率。</p>
<p>大表也可以拆成小表。</p>
<h1 id="适当冗余"><a href="#适当冗余" class="headerlink" title="适当冗余"></a>适当冗余</h1><p>1.被频繁引用且只能通过 Join 2张(或者更多)大表的方式才能得到的独立小字段。</p>
<p>2.这样的场景由于每次Join仅仅只是为了取得某个小字段的值，Join到的记录又大，会造成大量不必要的 IO，完全可以通过空间换取时间的方式来优化。不过，冗余的同时需要确保数据的一致性不会遭到破坏，确保更新的同时冗余字段也被更新。</p>
<h1 id="字段类型的选择"><a href="#字段类型的选择" class="headerlink" title="字段类型的选择"></a>字段类型的选择</h1><h2 id="更小的通常更好"><a href="#更小的通常更好" class="headerlink" title="更小的通常更好"></a>更小的通常更好</h2><p>应该尽量使用可以正确存储数据的最小数据类型，更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期更少，但是要确保没有低估需要存储的值的范围，如果无法确认哪个数据类型，就选择你认为不会超过范围的最小类型。</p>
<p>测试：<br>设计两张表，设计不同的数据类型，查看表的容量</p>
<h2 id="简单就好"><a href="#简单就好" class="headerlink" title="简单就好"></a>简单就好</h2><p>简单数据类型的操作通常需要更少的CPU周期，例如，<br>1、整型比字符操作代价更低，因为字符集和校对规则是字符比较比整型比较更复杂，<br>2、使用mysql自建类型而不是字符串来存储日期和时间<br>3、用整型存储IP地址</p>
<p>​		人们经常使用varchar(15)来存储ip地址，然而，它的本质是32位无符号整数不是字符串，可以使用INET_ATON()和INET_NTOA函数在这两种表示方法之间转换<br>​		案例：<br>​		select inet_aton(‘1.1.1.1’)<br>​		select inet_ntoa(16843009)</p>
<p>测试：<br>创建两张相同的表，改变日期的数据类型，查看SQL语句执行的速度</p>
<h2 id="尽量避免null"><a href="#尽量避免null" class="headerlink" title="尽量避免null"></a>尽量避免null</h2><p>如果查询中包含可为NULL的列，对mysql来说很难优化，因为可为null的列使得索引、索引统计和值比较都更加复杂，坦白来说，通常情况下null的列改为not null带来的性能提升比较小，所有没有必要将所有的表的schema进行修改，但是应该尽量避免设计成可为null的列</p>
<h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>可以使用的几种整数类型：TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT分别使用8，16，24，32，64位存储空间。<br>尽量使用满足需求的最小数据类型</p>
<h2 id="字符和字符串类型"><a href="#字符和字符串类型" class="headerlink" title="字符和字符串类型"></a>字符和字符串类型</h2><p>1、char长度固定，即每条数据占用等长字节空间；最大长度是255个字符，适合用在身份证号、手机号等定长字符串<br>2、varchar可变长度，可以设置最大长度；最大空间是65535个字节，适合用在长度可变的属性<br>3、text不设置长度，当不知道属性的最大长度时，适合用text<br>按照查询速度：char&gt;varchar&gt;text</p>
<h3 id="varchar"><a href="#varchar" class="headerlink" title="varchar"></a>varchar</h3><p>varchar根据实际内容长度保存数据。</p>
<p>1、使用最小的符合需求的长度。</p>
<p>2、varchar(n) n小于等于255使用额外一个字节保存长度，n&gt;255使用额外两个字节保存长度。</p>
<p>3、varchar(5)与varchar(255)保存同样的内容，硬盘存储空间相同，但内存空间占用不同，是指定的大小 。</p>
<p>4、varchar在mysql5.6之前变更长度，或者从255一下变更到255以上时时，都会导致锁表。</p>
<p>应用场景：</p>
<p>1、存储长度波动较大的数据，如：文章，有的会很短有的会很长</p>
<p>2、字符串很少更新的场景，每次更新后都会重算并使用额外存储空间保存长度</p>
<p>3、适合保存多字节字符，如：汉字，特殊字符等</p>
<h3 id="char"><a href="#char" class="headerlink" title="char"></a>char</h3><p>char固定长度的字符串</p>
<p>1、最大长度：255</p>
<p>2、会自动删除末尾的空格</p>
<p>3、检索效率、写效率 会比varchar高，以空间换时间</p>
<p>应用场景:</p>
<p>1、存储长度波动不大的数据，如：md5摘要</p>
<p>2、存储短字符串、经常更新的字符串</p>
<h3 id="BLOB和TEXT类型"><a href="#BLOB和TEXT类型" class="headerlink" title="BLOB和TEXT类型"></a>BLOB和TEXT类型</h3><p>MySQL 把每个 BLOB 和 TEXT 值当作一个独立的对象处理。<br>两者都是为了存储很大数据而设计的字符串类型，分别采用二进制和字符方式存储。</p>
<p>不推荐使用。使用时放到单独的表中。</p>
<h2 id="datetime和timestamp"><a href="#datetime和timestamp" class="headerlink" title="datetime和timestamp"></a>datetime和timestamp</h2><p>1、不要使用字符串类型来存储日期时间数据<br>2、日期时间类型通常比字符串占用的存储空间小<br>3、日期时间类型在进行查找过滤时可以利用日期来进行比对<br>4、日期时间类型还有着丰富的处理函数，可以方便的对时间类型进行日期计算<br>5、使用int存储日期时间不如使用timestamp类型</p>
<h3 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h3><p>占用8个字节</p>
<p>与时区无关，数据库底层时区配置，对datetime无效</p>
<p>可保存到毫秒</p>
<p>可保存时间范围大</p>
<p>不要使用字符串存储日期类型，占用空间大，损失日期类型函数的便捷性</p>
<h3 id="timestamp"><a href="#timestamp" class="headerlink" title="timestamp"></a>timestamp</h3><p>占用4个字节 如果使用毫秒占用7个字节</p>
<p>时间范围：1970-01-01到2038-01-19</p>
<p>精确到秒  可支持毫秒</p>
<p>采用整形存储</p>
<p>依赖数据库设置的时区</p>
<p>自动更新timestamp列的值</p>
<h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><p>占用的字节数比使用字符串、datetime、int存储要少，使用date类型只需要3个字节</p>
<p>使用date类型还可以利用日期时间函数进行日期之间的计算</p>
<p>date类型用于保存1000-01-01到9999-12-31之间的日期</p>
<p>datetime和timestamp选择：</p>
<p>时区可以用前端或后端处理</p>
<p>timestamp如果没有显示的指定时区，timestamp会调用操作系统底层函数__tz_convert()做交互。这个函数每次交互的时候，他会加锁，那么高并发情况下，会有性能抖动问题。</p>
<p>存储上7个字节与8个字节差别不大。</p>
<p>选择datetime。</p>
<h2 id="使用枚举代替字符串类型"><a href="#使用枚举代替字符串类型" class="headerlink" title="使用枚举代替字符串类型"></a>使用枚举代替字符串类型</h2><p>有时可以使用枚举类代替常用的字符串类型，mysql存储枚举类型会非常紧凑，会根据列表值的数据压缩到一个或两个字节中，mysql在内部会将每个值在列表中的位置保存为整数，并且在表的.frm文件中保存“数字-字符串”映射关系的查找表<br> create table enum_test(e enum(‘fish’,’apple’,’dog’) not null);<br> insert into enum_test(e) values(‘fish’),(‘dog’),(‘apple’);<br> select e+0 from enum_test;</p>
<h1 id="select性能查看"><a href="#select性能查看" class="headerlink" title="select性能查看"></a>select性能查看</h1><h2 id="show-profile"><a href="#show-profile" class="headerlink" title="show profile"></a>show profile</h2><p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/sql-statements.html">SQL Statements</a></p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/show.html">SHOW Statements</a></p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/show-profile.html">SHOW PROFILE Statement</a></p>
<p>使用show profile查询剖析工具，可以指定具体的type</p>
<p>此工具默认是禁用的，可以通过服务器变量在会话级别动态的修改<br><strong>set profiling&#x3D;1;</strong><br>当设置完成之后，在服务器上执行的所有语句，都会测量其耗费的时间和其他一些查询执行状态变更相关的数据。<br><strong>select * from emp;</strong><br>在mysql的命令行模式下只能显示两位小数的时间，可以使用如下命令查看具体的执行时间<br><strong>show profiles;</strong><br>执行如下命令可以查看详细的每个步骤的时间：<br><strong>show profile for query 1;</strong></p>
<p>type：</p>
<table>
<thead>
<tr>
<th>type</th>
<th>语法</th>
</tr>
</thead>
<tbody><tr>
<td>all：显示所有性能信息</td>
<td>show profile all for query n</td>
</tr>
<tr>
<td>block io：显示块io操作的次数</td>
<td>show  profile block io for query n</td>
</tr>
<tr>
<td>context switches：显示上下文切换次数，被动和主动</td>
<td>show profile context switches for query n</td>
</tr>
<tr>
<td>cpu：显示用户cpu时间、系统cpu时间</td>
<td>show profile cpu for query n</td>
</tr>
<tr>
<td>IPC：显示发送和接受的消息数量</td>
<td>show profile ipc for query n</td>
</tr>
<tr>
<td>Memory：暂未实现</td>
<td></td>
</tr>
<tr>
<td>page faults：显示页错误数量</td>
<td>show profile page faults for query n</td>
</tr>
<tr>
<td>source：显示源码中的函数名称与位置</td>
<td>show profile source for query n</td>
</tr>
<tr>
<td>swaps：显示swap的次数</td>
<td>show profile swaps for query n</td>
</tr>
</tbody></table>
<p>分析信息也可从 <code>INFORMATION_SCHEMA</code> <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/information-schema-profiling-table.html"><code>PROFILING</code></a>表中获得。请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/information-schema-profiling-table.html">第 26.3.24 节，“INFORMATION_SCHEMA PROFILING 表”</a>。例如，以下查询是等效的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> PROFILE <span class="hljs-keyword">FOR</span> QUERY <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">SELECT</span> STATE, FORMAT(DURATION, <span class="hljs-number">6</span>) <span class="hljs-keyword">AS</span> DURATION<br><span class="hljs-keyword">FROM</span> INFORMATION_SCHEMA.PROFILING<br><span class="hljs-keyword">WHERE</span> QUERY_ID <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> SEQ;<br></code></pre></td></tr></table></figure>

<h2 id="performance-schema"><a href="#performance-schema" class="headerlink" title="performance schema"></a>performance schema</h2><h3 id="performance-schema的介绍"><a href="#performance-schema的介绍" class="headerlink" title="performance_schema的介绍"></a>performance_schema的介绍</h3><p>​		<strong>MySQL的performance schema 用于监控MySQL server在一个较低级别的运行过程中的资源消耗、资源等待等情况</strong>。</p>
<p>​		特点如下：</p>
<p>​		1、提供了一种在数据库运行时实时检查server的内部执行情况的方法。performance_schema 数据库中的表使用performance_schema存储引擎。该数据库主要关注数据库运行过程中的性能相关的数据，与information_schema不同，information_schema主要关注server运行过程中的元数据信息</p>
<p>​		2、performance_schema通过监视server的事件来实现监视server内部运行情况， “事件”就是server内部活动中所做的任何事情以及对应的时间消耗，利用这些信息来判断server中的相关资源消耗在了哪里？一般来说，事件可以是函数调用、操作系统的等待、SQL语句执行的阶段（如sql语句执行过程中的parsing 或 sorting阶段）或者整个SQL语句与SQL语句集合。事件的采集可以方便的提供server中的相关存储引擎对磁盘文件、表I&#x2F;O、表锁等资源的同步调用信息。<br>​		3、performance_schema中的事件与写入二进制日志中的事件（描述数据修改的events）、事件计划调度程序（这是一种存储程序）的事件不同。performance_schema中的事件记录的是server执行某些活动对某些资源的消耗、耗时、这些活动执行的次数等情况。<br>​		4、performance_schema中的事件只记录在本地server的performance_schema中，其下的这些表中数据发生变化时不会被写入binlog中，也不会通过复制机制被复制到其他server中。<br>​		5、 当前活跃事件、历史事件和事件摘要相关的表中记录的信息。能提供某个事件的执行次数、使用时长。进而可用于分析某个特定线程、特定对象（如mutex或file）相关联的活动。<br>​		6、PERFORMANCE_SCHEMA存储引擎使用server源代码中的“检测点”来实现事件数据的收集。对于performance_schema实现机制本身的代码没有相关的单独线程来检测，这与其他功能（如复制或事件计划程序）不同<br>​		7、收集的事件数据存储在performance_schema数据库的表中。这些表可以使用SELECT语句查询，也可以使用SQL语句更新performance_schema数据库中的表记录（如动态修改performance_schema的setup_*开头的几个配置表，但要注意：配置表的更改会立即生效，这会影响数据收集）<br>​		8、performance_schema的表中的数据不会持久化存储在磁盘中，而是保存在内存中，一旦服务器重启，这些数据会丢失（包括配置表在内的整个performance_schema下的所有数据）<br>​		9、MySQL支持的所有平台中事件监控功能都可用，但不同平台中用于统计事件时间开销的计时器类型可能会有所差异。</p>
<h3 id="performance-schema入门"><a href="#performance-schema入门" class="headerlink" title="performance schema入门"></a>performance schema入门</h3><p>​		在mysql的5.7版本中，性能模式是默认开启的，如果想要显式的关闭的话需要修改配置文件，不能直接进行修改，会报错Variable ‘performance_schema’ is a read only variable。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--查看performance_schema的属性</span><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;performance_schema&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------+-------+</span><br><span class="hljs-operator">|</span> Variable_name      <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------+-------+</span><br><span class="hljs-operator">|</span> performance_schema <span class="hljs-operator">|</span> <span class="hljs-keyword">ON</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------+-------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)<br><br><span class="hljs-comment">--在配置文件中修改performance_schema的属性值，on表示开启，off表示关闭</span><br>[mysqld]<br>performance_schema<span class="hljs-operator">=</span><span class="hljs-keyword">ON</span><br><br><span class="hljs-comment">--切换数据库</span><br>use performance_schema;<br><br><span class="hljs-comment">--查看当前数据库下的所有表,会看到有很多表存储着相关的信息</span><br><span class="hljs-keyword">show</span> tables;<br><br><span class="hljs-comment">--可以通过show create table tablename来查看创建表的时候的表结构</span><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> setup_consumers;<br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+---------------------------------</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">Table</span>           <span class="hljs-operator">|</span> <span class="hljs-keyword">Create</span> <span class="hljs-keyword">Table</span>                    <br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+---------------------------------</span><br><span class="hljs-operator">|</span> setup_consumers <span class="hljs-operator">|</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `setup_consumers` (<br>  `NAME` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,                      <br>  `ENABLED` enum(<span class="hljs-string">&#x27;YES&#x27;</span>,<span class="hljs-string">&#x27;NO&#x27;</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>               <br>) ENGINE<span class="hljs-operator">=</span>PERFORMANCE_SCHEMA <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-operator">|</span>  <br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+---------------------------------</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)               <br></code></pre></td></tr></table></figure>

<p>​		想要搞明白后续的内容，同学们需要理解两个基本概念：</p>
<p>​		instruments: 生产者，用于采集mysql中各种各样的操作产生的事件信息，对应配置表中的配置项我们可以称为监控采集配置项。</p>
<p>​		consumers:消费者，对应的消费者表用于存储来自instruments采集的数据，对应配置表中的配置项我们可以称为消费存储配置项。</p>
<h3 id="performance-schema表的分类"><a href="#performance-schema表的分类" class="headerlink" title="performance_schema表的分类"></a>performance_schema表的分类</h3><p>​		performance_schema库下的表可以按照监视不同的纬度就行分组。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--语句事件记录表，这些表记录了语句事件信息，当前语句事件表events_statements_current、历史语句事件表events_statements_history和长语句历史事件表events_statements_history_long、以及聚合后的摘要表summary，其中，summary表还可以根据帐号(account)，主机(host)，程序(program)，线程(thread)，用户(user)和全局(global)再进行细分)</span><br><span class="hljs-keyword">show</span> tables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%statement%&#x27;</span>;<br><br><span class="hljs-comment">--等待事件记录表，与语句事件类型的相关记录表类似：</span><br><span class="hljs-keyword">show</span> tables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%wait%&#x27;</span>;<br><br><span class="hljs-comment">--阶段事件记录表，记录语句执行的阶段事件的表</span><br><span class="hljs-keyword">show</span> tables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%stage%&#x27;</span>;<br><br><span class="hljs-comment">--事务事件记录表，记录事务相关的事件的表</span><br><span class="hljs-keyword">show</span> tables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%transaction%&#x27;</span>;<br><br><span class="hljs-comment">--监控文件系统层调用的表</span><br><span class="hljs-keyword">show</span> tables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%file%&#x27;</span>;<br><br><span class="hljs-comment">--监视内存使用的表</span><br><span class="hljs-keyword">show</span> tables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%memory%&#x27;</span>;<br><br><span class="hljs-comment">--动态对performance_schema进行配置的配置表</span><br><span class="hljs-keyword">show</span> tables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%setup%&#x27;</span>;<br></code></pre></td></tr></table></figure>

<h3 id="performance-schema的简单配置与使用"><a href="#performance-schema的简单配置与使用" class="headerlink" title="performance_schema的简单配置与使用"></a>performance_schema的简单配置与使用</h3><p>​		数据库刚刚初始化并启动时，并非所有instruments(事件采集项，在采集项的配置表中每一项都有一个开关字段，或为YES，或为NO)和consumers(与采集项类似，也有一个对应的事件类型保存表配置项，为YES就表示对应的表保存性能数据，为NO就表示对应的表不保存性能数据)都启用了，所以默认不会收集所有的事件，可能你需要检测的事件并没有打开，需要进行设置，可以使用如下两个语句打开对应的instruments和consumers（行计数可能会因MySQL版本而异)。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--打开等待事件的采集器配置项开关，需要修改setup_instruments配置表中对应的采集器配置项</span><br><span class="hljs-keyword">UPDATE</span> setup_instruments <span class="hljs-keyword">SET</span> ENABLED <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;YES&#x27;</span>, TIMED <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;YES&#x27;</span><span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;wait%&#x27;</span>;<br><br><span class="hljs-comment">--打开等待事件的保存表配置开关，修改setup_consumers配置表中对应的配置项</span><br><span class="hljs-keyword">UPDATE</span> setup_consumers <span class="hljs-keyword">SET</span> ENABLED <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;YES&#x27;</span><span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%wait%&#x27;</span>;<br><br><span class="hljs-comment">--当配置完成之后可以查看当前server正在做什么，可以通过查询events_waits_current表来得知，该表中每个线程只包含一行数据，用于显示每个线程的最新监视事件</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> events_waits_current\G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>            THREAD_ID: <span class="hljs-number">11</span><br>             EVENT_ID: <span class="hljs-number">570</span><br>         END_EVENT_ID: <span class="hljs-number">570</span><br>           EVENT_NAME: wait<span class="hljs-operator">/</span>synch<span class="hljs-operator">/</span>mutex<span class="hljs-operator">/</span>innodb<span class="hljs-operator">/</span>buf_dblwr_mutex<br>               SOURCE: <br>          TIMER_START: <span class="hljs-number">4508505105239280</span><br>            TIMER_END: <span class="hljs-number">4508505105270160</span><br>           TIMER_WAIT: <span class="hljs-number">30880</span><br>                SPINS: <span class="hljs-keyword">NULL</span><br>        OBJECT_SCHEMA: <span class="hljs-keyword">NULL</span><br>          OBJECT_NAME: <span class="hljs-keyword">NULL</span><br>           INDEX_NAME: <span class="hljs-keyword">NULL</span><br>          OBJECT_TYPE: <span class="hljs-keyword">NULL</span><br>OBJECT_INSTANCE_BEGIN: <span class="hljs-number">67918392</span><br>     NESTING_EVENT_ID: <span class="hljs-keyword">NULL</span><br>   NESTING_EVENT_TYPE: <span class="hljs-keyword">NULL</span><br>            OPERATION: lock<br>      NUMBER_OF_BYTES: <span class="hljs-keyword">NULL</span><br>                FLAGS: <span class="hljs-keyword">NULL</span><br><span class="hljs-comment">/*该信息表示线程id为11的线程正在等待buf_dblwr_mutex锁，等待事件为30880</span><br><span class="hljs-comment">属性说明：</span><br><span class="hljs-comment">	id:事件来自哪个线程，事件编号是多少</span><br><span class="hljs-comment">	event_name:表示检测到的具体的内容</span><br><span class="hljs-comment">	source:表示这个检测代码在哪个源文件中以及行号</span><br><span class="hljs-comment">	timer_start:表示该事件的开始时间</span><br><span class="hljs-comment">	timer_end:表示该事件的结束时间</span><br><span class="hljs-comment">	timer_wait:表示该事件总的花费时间</span><br><span class="hljs-comment">注意：_current表中每个线程只保留一条记录，一旦线程完成工作，该表中不会再记录该线程的事件信息</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">_history表中记录每个线程应该执行完成的事件信息，但每个线程的事件信息只会记录10条，再多就会被覆盖，*_history_long表中记录所有线程的事件信息，但总记录数量是10000，超过就会被覆盖掉</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">select</span> thread_id,event_id,event_name,timer_wait <span class="hljs-keyword">from</span> events_waits_history <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> thread_id limit <span class="hljs-number">21</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">summary表提供所有事件的汇总信息，该组中的表以不同的方式汇总事件数据（如：按用户，按主机，按线程等等）。例如：要查看哪些instruments占用最多的时间，可以通过对events_waits_summary_global_by_event_name表的COUNT_STAR或SUM_TIMER_WAIT列进行查询（这两列是对事件的记录数执行COUNT（*）、事件记录的TIMER_WAIT列执行SUM（TIMER_WAIT）统计而来）</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">SELECT</span> EVENT_NAME,COUNT_STAR <span class="hljs-keyword">FROM</span> events_waits_summary_global_by_event_name  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> COUNT_STAR <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">instance表记录了哪些类型的对象会被检测。这些对象在被server使用时，在该表中将会产生一条事件记录，例如，file_instances表列出了文件I/O操作及其关联文件名</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> file_instances limit <span class="hljs-number">20</span>; <br></code></pre></td></tr></table></figure>

<h3 id="常用配置项的参数说明"><a href="#常用配置项的参数说明" class="headerlink" title="常用配置项的参数说明"></a>常用配置项的参数说明</h3><p>1、启动选项</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs sql">performance_schema_consumer_events_statements_current<span class="hljs-operator">=</span><span class="hljs-literal">TRUE</span><br>是否在mysql server启动时就开启events_statements_current表的记录功能(该表记录当前的语句事件信息)，启动之后也可以在setup_consumers表中使用<span class="hljs-keyword">UPDATE</span>语句进行动态更新setup_consumers配置表中的events_statements_current配置项，默认值为<span class="hljs-literal">TRUE</span><br><br>performance_schema_consumer_events_statements_history<span class="hljs-operator">=</span><span class="hljs-literal">TRUE</span><br>与performance_schema_consumer_events_statements_current选项类似，但该选项是用于配置是否记录语句事件短历史信息，默认为<span class="hljs-literal">TRUE</span><br><br>performance_schema_consumer_events_stages_history_long<span class="hljs-operator">=</span><span class="hljs-literal">FALSE</span><br>与performance_schema_consumer_events_statements_current选项类似，但该选项是用于配置是否记录语句事件长历史信息，默认为<span class="hljs-literal">FALSE</span><br><br>除了statement(语句)事件之外，还支持：wait(等待)事件、state(阶段)事件、transaction(事务)事件，他们与statement事件一样都有三个启动项分别进行配置，但这些等待事件默认未启用，如果需要在MySQL Server启动时一同启动，则通常需要写进my.cnf配置文件中<br>performance_schema_consumer_global_instrumentation<span class="hljs-operator">=</span><span class="hljs-literal">TRUE</span><br>是否在MySQL Server启动时就开启全局表（如：mutex_instances、rwlock_instances、cond_instances、file_instances、users、hostsaccounts、socket_summary_by_event_name、file_summary_by_instance等大部分的全局对象计数统计和事件汇总统计信息表 ）的记录功能，启动之后也可以在setup_consumers表中使用<span class="hljs-keyword">UPDATE</span>语句进行动态更新全局配置项<br>默认值为<span class="hljs-literal">TRUE</span><br><br>performance_schema_consumer_statements_digest<span class="hljs-operator">=</span><span class="hljs-literal">TRUE</span><br>是否在MySQL Server启动时就开启events_statements_summary_by_digest 表的记录功能，启动之后也可以在setup_consumers表中使用<span class="hljs-keyword">UPDATE</span>语句进行动态更新digest配置项<br>默认值为<span class="hljs-literal">TRUE</span><br><br>performance_schema_consumer_thread_instrumentation<span class="hljs-operator">=</span><span class="hljs-literal">TRUE</span><br>是否在MySQL Server启动时就开启<br><br>events_xxx_summary_by_yyy_by_event_name表的记录功能，启动之后也可以在setup_consumers表中使用<span class="hljs-keyword">UPDATE</span>语句进行动态更新线程配置项<br>默认值为<span class="hljs-literal">TRUE</span><br><br>performance_schema_instrument[<span class="hljs-operator">=</span>name]<br>是否在MySQL Server启动时就启用某些采集器，由于instruments配置项多达数千个，所以该配置项支持key<span class="hljs-operator">-</span><span class="hljs-keyword">value</span>模式，还支持<span class="hljs-operator">%</span>号进行通配等，如下:<br><br># [<span class="hljs-operator">=</span>name]可以指定为具体的Instruments名称（但是这样如果有多个需要指定的时候，就需要使用该选项多次），也可以使用通配符，可以指定instruments相同的前缀<span class="hljs-operator">+</span>通配符，也可以使用<span class="hljs-operator">%</span>代表所有的instruments<br><br>## 指定开启单个instruments<br><br><span class="hljs-comment">--performance-schema-instrument= &#x27;instrument_name=value&#x27;</span><br><br>## 使用通配符指定开启多个instruments<br><br><span class="hljs-comment">--performance-schema-instrument= &#x27;wait/synch/cond/%=COUNTED&#x27;</span><br><br>## 开关所有的instruments<br><br><span class="hljs-comment">--performance-schema-instrument= &#x27;%=ON&#x27;</span><br><br><span class="hljs-comment">--performance-schema-instrument= &#x27;%=OFF&#x27;</span><br><br>注意，这些启动选项要生效的前提是，需要设置performance_schema<span class="hljs-operator">=</span><span class="hljs-keyword">ON</span>。另外，这些启动选项虽然无法使用<span class="hljs-keyword">show</span> variables语句查看，但我们可以通过setup_instruments和setup_consumers表查询这些选项指定的值。<br></code></pre></td></tr></table></figure>

<p>2、系统变量</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%performance_schema%&#x27;</span>;<br><span class="hljs-comment">--重要的属性解释</span><br>performance_schema<span class="hljs-operator">=</span><span class="hljs-keyword">ON</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">控制performance_schema功能的开关，要使用MySQL的performance_schema，需要在mysqld启动时启用，以启用事件收集功能</span><br><span class="hljs-comment">该参数在5.7.x之前支持performance_schema的版本中默认关闭，5.7.x版本开始默认开启</span><br><span class="hljs-comment">注意：如果mysqld在初始化performance_schema时发现无法分配任何相关的内部缓冲区，则performance_schema将自动禁用，并将performance_schema设置为OFF</span><br><span class="hljs-comment">*/</span><br><br>performance_schema_digests_size<span class="hljs-operator">=</span><span class="hljs-number">10000</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">控制events_statements_summary_by_digest表中的最大行数。如果产生的语句摘要信息超过此最大值，便无法继续存入该表，此时performance_schema会增加状态变量</span><br><span class="hljs-comment">*/</span><br>performance_schema_events_statements_history_long_size<span class="hljs-operator">=</span><span class="hljs-number">10000</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">控制events_statements_history_long表中的最大行数，该参数控制所有会话在events_statements_history_long表中能够存放的总事件记录数，超过这个限制之后，最早的记录将被覆盖</span><br><span class="hljs-comment">全局变量，只读变量，整型值，5.6.3版本引入 * 5.6.x版本中，5.6.5及其之前的版本默认为10000，5.6.6及其之后的版本默认值为-1，通常情况下，自动计算的值都是10000 * 5.7.x版本中，默认值为-1，通常情况下，自动计算的值都是10000</span><br><span class="hljs-comment">*/</span><br>performance_schema_events_statements_history_size<span class="hljs-operator">=</span><span class="hljs-number">10</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">控制events_statements_history表中单个线程（会话）的最大行数，该参数控制单个会话在events_statements_history表中能够存放的事件记录数，超过这个限制之后，单个会话最早的记录将被覆盖</span><br><span class="hljs-comment">全局变量，只读变量，整型值，5.6.3版本引入 * 5.6.x版本中，5.6.5及其之前的版本默认为10，5.6.6及其之后的版本默认值为-1，通常情况下，自动计算的值都是10 * 5.7.x版本中，默认值为-1，通常情况下，自动计算的值都是10</span><br><span class="hljs-comment">除了statement(语句)事件之外，wait(等待)事件、state(阶段)事件、transaction(事务)事件，他们与statement事件一样都有三个参数分别进行存储限制配置，有兴趣的同学自行研究，这里不再赘述</span><br><span class="hljs-comment">*/</span><br>performance_schema_max_digest_length<span class="hljs-operator">=</span><span class="hljs-number">1024</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">用于控制标准化形式的SQL语句文本在存入performance_schema时的限制长度，该变量与max_digest_length变量相关(max_digest_length变量含义请自行查阅相关资料)</span><br><span class="hljs-comment">全局变量，只读变量，默认值1024字节，整型值，取值范围0~1048576</span><br><span class="hljs-comment">*/</span><br>performance_schema_max_sql_text_length<span class="hljs-operator">=</span><span class="hljs-number">1024</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">控制存入events_statements_current，events_statements_history和events_statements_history_long语句事件表中的SQL_TEXT列的最大SQL长度字节数。 超出系统变量performance_schema_max_sql_text_length的部分将被丢弃，不会记录，一般情况下不需要调整该参数，除非被截断的部分与其他SQL比起来有很大差异</span><br><span class="hljs-comment">全局变量，只读变量，整型值，默认值为1024字节，取值范围为0~1048576，5.7.6版本引入</span><br><span class="hljs-comment">降低系统变量performance_schema_max_sql_text_length值可以减少内存使用，但如果汇总的SQL中，被截断部分有较大差异，会导致没有办法再对这些有较大差异的SQL进行区分。 增加该系统变量值会增加内存使用，但对于汇总SQL来讲可以更精准地区分不同的部分。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<h3 id="重要配置表的相关说明"><a href="#重要配置表的相关说明" class="headerlink" title="重要配置表的相关说明"></a>重要配置表的相关说明</h3><p>​		配置表之间存在相互关联关系，按照配置影响的先后顺序，可添加为</p>
<p><img src="/.com//performanceschema%E9%85%8D%E7%BD%AE%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="performanceschema配置表"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/*</span><br><span class="hljs-comment">performance_timers表中记录了server中有哪些可用的事件计时器</span><br><span class="hljs-comment">字段解释：</span><br><span class="hljs-comment">	timer_name:表示可用计时器名称，CYCLE是基于CPU周期计数器的定时器</span><br><span class="hljs-comment">	timer_frequency:表示每秒钟对应的计时器单位的数量,CYCLE计时器的换算值与CPU的频率相关、</span><br><span class="hljs-comment">	timer_resolution:计时器精度值，表示在每个计时器被调用时额外增加的值</span><br><span class="hljs-comment">	timer_overhead:表示在使用定时器获取事件时开销的最小周期值</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> performance_timers;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">setup_timers表中记录当前使用的事件计时器信息</span><br><span class="hljs-comment">字段解释：</span><br><span class="hljs-comment">	name:计时器类型，对应某个事件类别</span><br><span class="hljs-comment">	timer_name:计时器类型名称</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> setup_timers;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">setup_consumers表中列出了consumers可配置列表项</span><br><span class="hljs-comment">字段解释：</span><br><span class="hljs-comment">	NAME：consumers配置名称</span><br><span class="hljs-comment">	ENABLED：consumers是否启用，有效值为YES或NO，此列可以使用UPDATE语句修改。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> setup_consumers;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">setup_instruments 表列出了instruments 列表配置项，即代表了哪些事件支持被收集：</span><br><span class="hljs-comment">字段解释：</span><br><span class="hljs-comment">	NAME：instruments名称，instruments名称可能具有多个部分并形成层次结构</span><br><span class="hljs-comment">	ENABLED：instrumetns是否启用，有效值为YES或NO，此列可以使用UPDATE语句修改。如果设置为NO，则这个instruments不会被执行，不会产生任何的事件信息</span><br><span class="hljs-comment">	TIMED：instruments是否收集时间信息，有效值为YES或NO，此列可以使用UPDATE语句修改，如果设置为NO，则这个instruments不会收集时间信息</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> setup_instruments;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">setup_actors表的初始内容是匹配任何用户和主机，因此对于所有前台线程，默认情况下启用监视和历史事件收集功能</span><br><span class="hljs-comment">字段解释：</span><br><span class="hljs-comment">	HOST：与grant语句类似的主机名，一个具体的字符串名字，或使用“％”表示“任何主机”</span><br><span class="hljs-comment">	USER：一个具体的字符串名称，或使用“％”表示“任何用户”</span><br><span class="hljs-comment">	ROLE：当前未使用，MySQL 8.0中才启用角色功能</span><br><span class="hljs-comment">	ENABLED：是否启用与HOST，USER，ROLE匹配的前台线程的监控功能，有效值为：YES或NO</span><br><span class="hljs-comment">	HISTORY：是否启用与HOST， USER，ROLE匹配的前台线程的历史事件记录功能，有效值为：YES或NO</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> setup_actors;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">setup_objects表控制performance_schema是否监视特定对象。默认情况下，此表的最大行数为100行。</span><br><span class="hljs-comment">字段解释：</span><br><span class="hljs-comment">	OBJECT_TYPE：instruments类型，有效值为：“EVENT”（事件调度器事件）、“FUNCTION”（存储函数）、“PROCEDURE”（存储过程）、“TABLE”（基表）、“TRIGGER”（触发器），TABLE对象类型的配置会影响表I/O事件（wait/io/table/sql/handler instrument）和表锁事件（wait/lock/table/sql/handler instrument）的收集</span><br><span class="hljs-comment">	OBJECT_SCHEMA：某个监视类型对象涵盖的数据库名称，一个字符串名称，或“％”(表示“任何数据库”)</span><br><span class="hljs-comment">	OBJECT_NAME：某个监视类型对象涵盖的表名，一个字符串名称，或“％”(表示“任何数据库内的对象”)</span><br><span class="hljs-comment">	ENABLED：是否开启对某个类型对象的监视功能，有效值为：YES或NO。此列可以修改</span><br><span class="hljs-comment">	TIMED：是否开启对某个类型对象的时间收集功能，有效值为：YES或NO，此列可以修改</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> setup_objects;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">threads表对于每个server线程生成一行包含线程相关的信息，</span><br><span class="hljs-comment">字段解释：</span><br><span class="hljs-comment">	THREAD_ID：线程的唯一标识符（ID）</span><br><span class="hljs-comment">	NAME：与server中的线程检测代码相关联的名称(注意，这里不是instruments名称)</span><br><span class="hljs-comment">	TYPE：线程类型，有效值为：FOREGROUND、BACKGROUND。分别表示前台线程和后台线程</span><br><span class="hljs-comment">	PROCESSLIST_ID：对应INFORMATION_SCHEMA.PROCESSLIST表中的ID列。</span><br><span class="hljs-comment">	PROCESSLIST_USER：与前台线程相关联的用户名，对于后台线程为NULL。</span><br><span class="hljs-comment">	PROCESSLIST_HOST：与前台线程关联的客户端的主机名，对于后台线程为NULL。</span><br><span class="hljs-comment">	PROCESSLIST_DB：线程的默认数据库，如果没有，则为NULL。</span><br><span class="hljs-comment">	PROCESSLIST_COMMAND：对于前台线程，该值代表着当前客户端正在执行的command类型，如果是sleep则表示当前会话处于空闲状态</span><br><span class="hljs-comment">	PROCESSLIST_TIME：当前线程已处于当前线程状态的持续时间（秒）</span><br><span class="hljs-comment">	PROCESSLIST_STATE：表示线程正在做什么事情。</span><br><span class="hljs-comment">	PROCESSLIST_INFO：线程正在执行的语句，如果没有执行任何语句，则为NULL。</span><br><span class="hljs-comment">	PARENT_THREAD_ID：如果这个线程是一个子线程（由另一个线程生成），那么该字段显示其父线程ID</span><br><span class="hljs-comment">	ROLE：暂未使用</span><br><span class="hljs-comment">	INSTRUMENTED：线程执行的事件是否被检测。有效值：YES、NO </span><br><span class="hljs-comment">	HISTORY：是否记录线程的历史事件。有效值：YES、NO * </span><br><span class="hljs-comment">	THREAD_OS_ID：由操作系统层定义的线程或任务标识符（ID）：</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> threads<br></code></pre></td></tr></table></figure>

<p>注意：在performance_schema库中还包含了很多其他的库和表，能对数据库的性能做完整的监控，大家需要参考官网详细了解。</p>
<h3 id="performance-schema实践操作"><a href="#performance-schema实践操作" class="headerlink" title="performance_schema实践操作"></a>performance_schema实践操作</h3><p>​		基本了解了表的相关信息之后，可以通过这些表进行实际的查询操作来进行实际的分析。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--1、哪类的SQL执行最多？</span><br><span class="hljs-keyword">SELECT</span> DIGEST_TEXT,COUNT_STAR,FIRST_SEEN,LAST_SEEN <span class="hljs-keyword">FROM</span> events_statements_summary_by_digest <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> COUNT_STAR <span class="hljs-keyword">DESC</span><br><span class="hljs-comment">--2、哪类SQL的平均响应时间最多？</span><br><span class="hljs-keyword">SELECT</span> DIGEST_TEXT,AVG_TIMER_WAIT <span class="hljs-keyword">FROM</span> events_statements_summary_by_digest <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> COUNT_STAR <span class="hljs-keyword">DESC</span><br><span class="hljs-comment">--3、哪类SQL排序记录数最多？</span><br><span class="hljs-keyword">SELECT</span> DIGEST_TEXT,SUM_SORT_ROWS <span class="hljs-keyword">FROM</span> events_statements_summary_by_digest <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> COUNT_STAR <span class="hljs-keyword">DESC</span><br><span class="hljs-comment">--4、哪类SQL扫描记录数最多？</span><br><span class="hljs-keyword">SELECT</span> DIGEST_TEXT,SUM_ROWS_EXAMINED <span class="hljs-keyword">FROM</span> events_statements_summary_by_digest <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> COUNT_STAR <span class="hljs-keyword">DESC</span><br><span class="hljs-comment">--5、哪类SQL使用临时表最多？</span><br><span class="hljs-keyword">SELECT</span> DIGEST_TEXT,SUM_CREATED_TMP_TABLES,SUM_CREATED_TMP_DISK_TABLES <span class="hljs-keyword">FROM</span> events_statements_summary_by_digest <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> COUNT_STAR <span class="hljs-keyword">DESC</span><br><span class="hljs-comment">--6、哪类SQL返回结果集最多？</span><br><span class="hljs-keyword">SELECT</span> DIGEST_TEXT,SUM_ROWS_SENT <span class="hljs-keyword">FROM</span> events_statements_summary_by_digest <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> COUNT_STAR <span class="hljs-keyword">DESC</span><br><span class="hljs-comment">--7、哪个表物理IO最多？</span><br><span class="hljs-keyword">SELECT</span> file_name,event_name,SUM_NUMBER_OF_BYTES_READ,SUM_NUMBER_OF_BYTES_WRITE <span class="hljs-keyword">FROM</span> file_summary_by_instance <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> SUM_NUMBER_OF_BYTES_READ <span class="hljs-operator">+</span> SUM_NUMBER_OF_BYTES_WRITE <span class="hljs-keyword">DESC</span><br><span class="hljs-comment">--8、哪个表逻辑IO最多？</span><br><span class="hljs-keyword">SELECT</span> object_name,COUNT_READ,COUNT_WRITE,COUNT_FETCH,SUM_TIMER_WAIT <span class="hljs-keyword">FROM</span> table_io_waits_summary_by_table <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> sum_timer_wait <span class="hljs-keyword">DESC</span><br><span class="hljs-comment">--9、哪个索引访问最多？</span><br><span class="hljs-keyword">SELECT</span> OBJECT_NAME,INDEX_NAME,COUNT_FETCH,COUNT_INSERT,COUNT_UPDATE,COUNT_DELETE <span class="hljs-keyword">FROM</span> table_io_waits_summary_by_index_usage <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> SUM_TIMER_WAIT <span class="hljs-keyword">DESC</span><br><span class="hljs-comment">--10、哪个索引从来没有用过？</span><br><span class="hljs-keyword">SELECT</span> OBJECT_SCHEMA,OBJECT_NAME,INDEX_NAME <span class="hljs-keyword">FROM</span> table_io_waits_summary_by_index_usage <span class="hljs-keyword">WHERE</span> INDEX_NAME <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">AND</span> COUNT_STAR <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">AND</span> OBJECT_SCHEMA <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-string">&#x27;mysql&#x27;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> OBJECT_SCHEMA,OBJECT_NAME;<br><span class="hljs-comment">--11、哪个等待事件消耗时间最多？</span><br><span class="hljs-keyword">SELECT</span> EVENT_NAME,COUNT_STAR,SUM_TIMER_WAIT,AVG_TIMER_WAIT <span class="hljs-keyword">FROM</span> events_waits_summary_global_by_event_name <span class="hljs-keyword">WHERE</span> event_name <span class="hljs-operator">!=</span> <span class="hljs-string">&#x27;idle&#x27;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> SUM_TIMER_WAIT <span class="hljs-keyword">DESC</span><br><span class="hljs-comment">--12-1、剖析某条SQL的执行情况，包括statement信息，stege信息，wait信息</span><br><span class="hljs-keyword">SELECT</span> EVENT_ID,sql_text <span class="hljs-keyword">FROM</span> events_statements_history <span class="hljs-keyword">WHERE</span> sql_text <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%count(*)%&#x27;</span>;<br><span class="hljs-comment">--12-2、查看每个阶段的时间消耗</span><br><span class="hljs-keyword">SELECT</span> event_id,EVENT_NAME,SOURCE,TIMER_END <span class="hljs-operator">-</span> TIMER_START <span class="hljs-keyword">FROM</span> events_stages_history_long <span class="hljs-keyword">WHERE</span> NESTING_EVENT_ID <span class="hljs-operator">=</span> <span class="hljs-number">1553</span>;<br><span class="hljs-comment">--12-3、查看每个阶段的锁等待情况</span><br><span class="hljs-keyword">SELECT</span> event_id,event_name,source,timer_wait,object_name,index_name,operation,nesting_event_id <span class="hljs-keyword">FROM</span> events_waits_history_longWHERE nesting_event_id <span class="hljs-operator">=</span> <span class="hljs-number">1553</span>;<br></code></pre></td></tr></table></figure>

<h2 id="SHOW-PROCESSLIST"><a href="#SHOW-PROCESSLIST" class="headerlink" title="SHOW PROCESSLIST"></a>SHOW PROCESSLIST</h2><p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/show-processlist.html"><code>SHOW PROCESSLIST</code></a>从 MySQL 8.0.22 开始，基于 Performance Schema 表 的替代实现 可用<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/performance-schema-processlist-table.html"><code>processlist</code></a>，与默认<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/show-processlist.html"><code>SHOW PROCESSLIST</code></a> 实现不同，它不需要互斥体并且具有更好的性能特征。有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/performance-schema-processlist-table.html">第 27.12.21.5 节，“进程列表表”</a>。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>字段说明</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>表示session id</td>
</tr>
<tr>
<td>user</td>
<td>表示操作的用户</td>
</tr>
<tr>
<td>host</td>
<td>表示操作的主机</td>
</tr>
<tr>
<td>db</td>
<td>表示操作的数据库</td>
</tr>
<tr>
<td>command</td>
<td>表示当前状态</td>
</tr>
<tr>
<td></td>
<td>sleep：线程正在等待客户端发送新的请求</td>
</tr>
<tr>
<td></td>
<td>query：线程正在执行查询或正在将结果发送给客户端</td>
</tr>
<tr>
<td></td>
<td>locked：在mysql的服务层，该线程正在等待表锁</td>
</tr>
<tr>
<td></td>
<td>analyzing and statistics：线程正在收集存储引擎的统计信息，并生成查询的执行计划</td>
</tr>
<tr>
<td></td>
<td>Copying to tmp table：线程正在执行查询，并且将其结果集都复制到一个临时表中</td>
</tr>
<tr>
<td></td>
<td>sorting result：线程正在对结果集进行排序</td>
</tr>
<tr>
<td></td>
<td>sending data：线程可能在多个状态之间传送数据，或者在生成结果集或者向客户端返回数据</td>
</tr>
<tr>
<td>info</td>
<td>表示详细的sql语句</td>
</tr>
<tr>
<td>time</td>
<td>表示相应命令执行时间</td>
</tr>
<tr>
<td>state</td>
<td>表示命令执行状态</td>
</tr>
</tbody></table>
<h1 id="mysql-执行计划"><a href="#mysql-执行计划" class="headerlink" title="mysql 执行计划"></a>mysql 执行计划</h1><p>​       在企业的应用场景中，为了知道优化SQL语句的执行，需要查看SQL语句的具体执行过程，以加快SQL语句的执行效率。</p>
<p>​       可以使用explain+SQL语句来模拟优化器执行SQL查询语句，从而知道mysql是如何处理sql语句的。</p>
<p>​	   官网地址： <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.5/en/explain-output.html">https://dev.mysql.com/doc/refman/5.5/en/explain-output.html</a> </p>
<h2 id="执行计划中包含的信息"><a href="#执行计划中包含的信息" class="headerlink" title="执行计划中包含的信息"></a>执行计划中包含的信息</h2><table>
<thead>
<tr>
<th align="center">Column</th>
<th align="center">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="center">id</td>
<td align="center">The <code>SELECT</code> identifier</td>
</tr>
<tr>
<td align="center">select_type</td>
<td align="center">The <code>SELECT</code> type</td>
</tr>
<tr>
<td align="center">table</td>
<td align="center">The table for the output row</td>
</tr>
<tr>
<td align="center">partitions</td>
<td align="center">The matching partitions</td>
</tr>
<tr>
<td align="center">type</td>
<td align="center">The join type</td>
</tr>
<tr>
<td align="center">possible_keys</td>
<td align="center">The possible indexes to choose</td>
</tr>
<tr>
<td align="center">key</td>
<td align="center">The index actually chosen</td>
</tr>
<tr>
<td align="center">key_len</td>
<td align="center">The length of the chosen key</td>
</tr>
<tr>
<td align="center">ref</td>
<td align="center">The columns compared to the index</td>
</tr>
<tr>
<td align="center">rows</td>
<td align="center">Estimate of rows to be examined</td>
</tr>
<tr>
<td align="center">filtered</td>
<td align="center">Percentage of rows filtered by table condition</td>
</tr>
<tr>
<td align="center">extra</td>
<td align="center">Additional information</td>
</tr>
</tbody></table>
<p><strong>id</strong></p>
<p>select查询的序列号，包含一组数字，表示查询中执行select子句或者操作表的顺序</p>
<p>id号分为三种情况：</p>
<p>​		1、如果id相同，那么执行顺序从上到下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.deptno <span class="hljs-operator">=</span> d.deptno <span class="hljs-keyword">join</span> salgrade sg <span class="hljs-keyword">on</span> e.sal <span class="hljs-keyword">between</span> sg.losal <span class="hljs-keyword">and</span> sg.hisal;<br></code></pre></td></tr></table></figure>

<p>​		2、如果id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">where</span> e.deptno <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> d.deptno <span class="hljs-keyword">from</span> dept d <span class="hljs-keyword">where</span> d.dname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;SALES&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>​		3、id相同和不同的，同时存在：相同的可以认为是一组，从上往下顺序执行，在所有组中，id值越大，优先级越高，越先执行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.deptno <span class="hljs-operator">=</span> d.deptno <span class="hljs-keyword">join</span> salgrade sg <span class="hljs-keyword">on</span> e.sal <span class="hljs-keyword">between</span> sg.losal <span class="hljs-keyword">and</span> sg.hisal <span class="hljs-keyword">where</span> e.deptno <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> d.deptno <span class="hljs-keyword">from</span> dept d <span class="hljs-keyword">where</span> d.dname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;SALES&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p><strong>select_type</strong></p>
<p>主要用来分辨查询的类型，是普通查询还是联合查询还是子查询</p>
<table>
<thead>
<tr>
<th align="center"><code>select_type</code> Value</th>
<th align="center">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SIMPLE</td>
<td align="center">Simple SELECT (not using UNION or subqueries)</td>
</tr>
<tr>
<td align="center">PRIMARY</td>
<td align="center">Outermost SELECT</td>
</tr>
<tr>
<td align="center">UNION</td>
<td align="center">Second or later SELECT statement in a UNION</td>
</tr>
<tr>
<td align="center">DEPENDENT UNION</td>
<td align="center">Second or later SELECT statement in a UNION, dependent on outer query</td>
</tr>
<tr>
<td align="center">UNION RESULT</td>
<td align="center">Result of a UNION.</td>
</tr>
<tr>
<td align="center">SUBQUERY</td>
<td align="center">First SELECT in subquery</td>
</tr>
<tr>
<td align="center">DEPENDENT SUBQUERY</td>
<td align="center">First SELECT in subquery, dependent on outer query</td>
</tr>
<tr>
<td align="center">DERIVED</td>
<td align="center">Derived table</td>
</tr>
<tr>
<td align="center">UNCACHEABLE SUBQUERY</td>
<td align="center">A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td>
</tr>
<tr>
<td align="center">UNCACHEABLE UNION</td>
<td align="center">The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--sample:简单的查询，不包含子查询和union</span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp;<br><br><span class="hljs-comment">--primary:查询中若包含任何复杂的子查询，最外层查询则被标记为Primary</span><br>explain <span class="hljs-keyword">select</span> staname,ename supname <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> ename staname,mgr <span class="hljs-keyword">from</span> emp) t <span class="hljs-keyword">join</span> emp <span class="hljs-keyword">on</span> t.mgr<span class="hljs-operator">=</span>emp.empno ;<br><br><span class="hljs-comment">--union:若第二个select出现在union之后，则被标记为union</span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> deptno <span class="hljs-operator">=</span> <span class="hljs-number">10</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-operator">&gt;</span><span class="hljs-number">2000</span>;<br><br><span class="hljs-comment">--dependent union:跟union类似，此处的depentent表示union或union all联合而成的结果会受外部表影响</span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">where</span> e.empno  <span class="hljs-keyword">in</span> ( <span class="hljs-keyword">select</span> empno <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> deptno <span class="hljs-operator">=</span> <span class="hljs-number">10</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> empno <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-operator">&gt;</span><span class="hljs-number">2000</span>)<br><br><span class="hljs-comment">--union result:从union表获取结果的select</span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> deptno <span class="hljs-operator">=</span> <span class="hljs-number">10</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-operator">&gt;</span><span class="hljs-number">2000</span>;<br><br><span class="hljs-comment">--subquery:在select或者where列表中包含子查询</span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(sal) <span class="hljs-keyword">from</span> emp) ;<br><br><span class="hljs-comment">--dependent subquery:subquery的子查询要受到外部表查询的影响</span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">where</span> e.deptno <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> deptno <span class="hljs-keyword">from</span> dept);<br><br><span class="hljs-comment">--DERIVED: from子句中出现的子查询，也叫做派生类，</span><br>explain <span class="hljs-keyword">select</span> staname,ename supname <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> ename staname,mgr <span class="hljs-keyword">from</span> emp) t <span class="hljs-keyword">join</span> emp <span class="hljs-keyword">on</span> t.mgr<span class="hljs-operator">=</span>emp.empno ;<br><br><span class="hljs-comment">--UNCACHEABLE SUBQUERY：表示使用子查询的结果不能被缓存</span><br> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> empno <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> empno <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> deptno<span class="hljs-operator">=</span>@<span class="hljs-variable">@sort</span>_buffer_size);<br> <br><span class="hljs-comment">--uncacheable union:表示union的查询结果不能被缓存：sql语句未验证</span><br></code></pre></td></tr></table></figure>

<p><strong>table</strong></p>
<p>对应行正在访问哪一个表，表名或者别名，可能是临时表或者union合并结果集<br>        1、如果是具体的表名，则表明从实际的物理表中获取数据，当然也可以是表的别名</p>
<p>​		2、表名是derivedN的形式，表示使用了id为N的查询产生的衍生表</p>
<p>​		3、当有union result的时候，表名是union n1,n2等的形式，n1,n2表示参与union的id</p>
<p><strong>type</strong></p>
<p>type显示的是访问类型，访问类型表示我是以何种方式去访问我们的数据，最容易想的是全表扫描，直接暴力的遍历一张表去寻找需要的数据，效率非常低下，访问的类型有很多，效率从最好到最坏依次是：</p>
<p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL </p>
<p>一般情况下，得保证查询至少达到range级别，最好能达到ref</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--all:全表扫描，一般情况下出现这样的sql语句而且数据量比较大的话那么就需要进行优化。</span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp;<br><br><span class="hljs-comment">--index：全索引扫描这个比all的效率要好，主要有两种情况，一种是当前的查询时覆盖索引，即我们需要的数据在索引中就可以索取，或者是使用了索引进行排序，这样就避免数据的重排序</span><br>explain  <span class="hljs-keyword">select</span> empno <span class="hljs-keyword">from</span> emp;<br><br><span class="hljs-comment">--range：表示利用索引查询的时候限制了范围，在指定范围内进行查询，这样避免了index的全索引扫描，适用的操作符： =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, BETWEEN, LIKE, or IN() </span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> empno <span class="hljs-keyword">between</span> <span class="hljs-number">7000</span> <span class="hljs-keyword">and</span> <span class="hljs-number">7500</span>;<br><br><span class="hljs-comment">--index_subquery：利用索引来关联子查询，不再扫描全表</span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> emp.job <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> job <span class="hljs-keyword">from</span> t_job);<br><br><span class="hljs-comment">--unique_subquery:该连接类型类似与index_subquery,使用的是唯一索引</span><br> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">where</span> e.deptno <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> deptno <span class="hljs-keyword">from</span> dept);<br> <br><span class="hljs-comment">--index_merge：在查询过程中需要多个索引组合使用，没有模拟出来</span><br><br><span class="hljs-comment">--ref_or_null：对于某个字段即需要关联条件，也需要null值的情况下，查询优化器会选择这种访问方式</span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">where</span>  e.mgr <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">or</span> e.mgr<span class="hljs-operator">=</span><span class="hljs-number">7369</span>;<br><br><span class="hljs-comment">--ref：使用了非唯一性索引进行数据的查找</span><br> <span class="hljs-keyword">create</span> index idx_3 <span class="hljs-keyword">on</span> emp(deptno);<br> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp e,dept d <span class="hljs-keyword">where</span> e.deptno <span class="hljs-operator">=</span>d.deptno;<br><br><span class="hljs-comment">--eq_ref ：使用唯一性索引进行数据查找</span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp,emp2 <span class="hljs-keyword">where</span> emp.empno <span class="hljs-operator">=</span> emp2.empno;<br><br><span class="hljs-comment">--const：这个表至多有一个匹配行，</span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> empno <span class="hljs-operator">=</span> <span class="hljs-number">7369</span>;<br> <br><span class="hljs-comment">--system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现</span><br></code></pre></td></tr></table></figure>

<p> <strong>possible_keys</strong> </p>
<p>​        显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp,dept <span class="hljs-keyword">where</span> emp.deptno <span class="hljs-operator">=</span> dept.deptno <span class="hljs-keyword">and</span> emp.deptno <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>

<p><strong>key</strong></p>
<p>​		实际使用的索引，如果为null，则没有使用索引，查询中若使用了覆盖索引，则该索引和查询的select字段重叠。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp,dept <span class="hljs-keyword">where</span> emp.deptno <span class="hljs-operator">=</span> dept.deptno <span class="hljs-keyword">and</span> emp.deptno <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>

<p><strong>key_len</strong></p>
<p>表示索引中使用的字节数，可以通过key_len计算查询中使用的索引长度，在不损失精度的情况下长度越短越好。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp,dept <span class="hljs-keyword">where</span> emp.deptno <span class="hljs-operator">=</span> dept.deptno <span class="hljs-keyword">and</span> emp.deptno <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>

<p><strong>ref</strong></p>
<p>显示索引的哪一列被使用了，如果可能的话，是一个常数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp,dept <span class="hljs-keyword">where</span> emp.deptno <span class="hljs-operator">=</span> dept.deptno <span class="hljs-keyword">and</span> emp.deptno <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>

<p><strong>rows</strong></p>
<p>根据表的统计信息及索引使用情况，大致估算出找出所需记录需要读取的行数，此参数很重要，直接反应的sql找了多少数据，在完成目的的情况下越少越好</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp;<br></code></pre></td></tr></table></figure>

<p><strong>extra</strong></p>
<p>包含额外的信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--using filesort:说明mysql无法利用索引进行排序，只能利用排序算法进行排序，会消耗额外的位置</span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> sal;<br><br><span class="hljs-comment">--using temporary:建立临时表来保存中间结果，查询完成之后把临时表删除</span><br>explain <span class="hljs-keyword">select</span> ename,<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> deptno <span class="hljs-operator">=</span> <span class="hljs-number">10</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> ename;<br><br><span class="hljs-comment">--using index:这个表示当前的查询时覆盖索引的，直接从索引中读取数据，而不用访问数据表。如果同时出现using where 表名索引被用来执行索引键值的查找，如果没有，表面索引被用来读取数据，而不是真的查找</span><br>explain <span class="hljs-keyword">select</span> deptno,<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno limit <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">--using where:使用where进行条件过滤</span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">--using join buffer:使用连接缓存，情况没有模拟出来</span><br><br><span class="hljs-comment">--impossible where：where语句的结果总是false</span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> empno <span class="hljs-operator">=</span> <span class="hljs-number">7469</span>;<br></code></pre></td></tr></table></figure>

<h1 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h1><h2 id="查询慢的原因"><a href="#查询慢的原因" class="headerlink" title="查询慢的原因"></a>查询慢的原因</h2><p>网络</p>
<p>CPU</p>
<p>IO</p>
<p>上下文切换</p>
<p>系统调用</p>
<p>生成统计信息</p>
<p>锁等待时间</p>
<h2 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h2><h3 id="查询性能低下的主要原因是访问的数据太多，某些查询不可避免的需要筛选大量的数据，我们可以通过减少访问数据量的方式进行优化"><a href="#查询性能低下的主要原因是访问的数据太多，某些查询不可避免的需要筛选大量的数据，我们可以通过减少访问数据量的方式进行优化" class="headerlink" title="查询性能低下的主要原因是访问的数据太多，某些查询不可避免的需要筛选大量的数据，我们可以通过减少访问数据量的方式进行优化"></a>查询性能低下的主要原因是访问的数据太多，某些查询不可避免的需要筛选大量的数据，我们可以通过减少访问数据量的方式进行优化</h3><p>1.确认应用程序是否在检索大量超过需要的数据</p>
<p>2.确认mysql服务器层是否在分析大量超过需要的数据行</p>
<h3 id="是否向数据库请求了不需要的数据："><a href="#是否向数据库请求了不需要的数据：" class="headerlink" title="是否向数据库请求了不需要的数据："></a>是否向数据库请求了不需要的数据：</h3><h4 id="查询不需要的记录："><a href="#查询不需要的记录：" class="headerlink" title="查询不需要的记录："></a>查询不需要的记录：</h4><p>我们常常会误以为mysql会只返回需要的数据，实际上mysql却是先返回全部结果再进行计算，在日常的开发习惯中，经常是先用select语句查询大量的结果，然后获取前面的N行后关闭结果集。</p>
<p>优化方式是在查询后面添加limit</p>
<h4 id="多表关联时返回全部列"><a href="#多表关联时返回全部列" class="headerlink" title="多表关联时返回全部列"></a>多表关联时返回全部列</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> actor <br><span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> film_actor <span class="hljs-keyword">using</span>(actor_id) <br><span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> film <span class="hljs-keyword">using</span>(film_id) <br><span class="hljs-keyword">where</span> film.title<span class="hljs-operator">=</span><span class="hljs-string">&#x27;Academy Dinosaur&#x27;</span>;<br><br><span class="hljs-keyword">select</span> actor.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> actor...;<br></code></pre></td></tr></table></figure>

<h4 id="总是取出全部列"><a href="#总是取出全部列" class="headerlink" title="总是取出全部列"></a>总是取出全部列</h4><p>在公司的企业需求中，禁止使用select *,虽然这种方式能够简化开发，但是会影响查询的性能，所以尽量不要使用</p>
<h4 id="重复查询相同的数据"><a href="#重复查询相同的数据" class="headerlink" title="重复查询相同的数据"></a>重复查询相同的数据</h4><p>如果需要不断的重复执行相同的查询，且每次返回完全相同的数据，因此，基于这样的应用场景，我们可以将这部分数据缓存起来，这样的话能够提高查询效率</p>
<h2 id="执行过程的优化"><a href="#执行过程的优化" class="headerlink" title="执行过程的优化"></a>执行过程的优化</h2><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>在解析一个查询语句之前，如果查询缓存是打开的，那么mysql会优先检查这个查询是否命中查询缓存中的数据，如果查询恰好命中了查询缓存，那么会在返回结果之前会检查用户权限，如果权限没有问题，那么mysql会跳过所有的阶段，就直接从缓存中拿到结果并返回给客户端</p>
<h3 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h3><p>mysql查询完缓存之后会经过以下几个步骤：分析器、优化SQL执行计划，这几个步骤出现任何的错误，都可能会终止查询</p>
<h4 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h4><p>mysql通过关键字将SQL语句进行解析，并生成一颗解析树，mysql分析器将使用mysql语法规则验证和解析查询，例如验证使用使用了错误的关键字或者顺序是否正确等等，分析器会进一步检查解析树是否合法，例如表名和列名是否存在，是否有歧义，还会验证权限等等</p>
<h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><p>当语法树没有问题之后，相应的要由优化器将其转成执行计划，一条查询语句可以使用非常多的执行方式，最后都可以得到对应的结果，但是不同的执行方式带来的效率是不同的，优化器的最主要目的就是要选择最有效的执行计划</p>
<p>mysql使用的是基于成本的优化器，在优化的时候会尝试预测一个查询使用某种查询计划时候的成本，并选择其中成本最小的一个。</p>
<p>select count(*) from film_actor;<br>show status like ‘last_query_cost’;<br>可以看到这条查询语句大概需要做1104个数据页才能找到对应的数据，这是经过一系列的统计信息计算来的</p>
<p>每个表或者索引的页面个数；</p>
<p>索引的基数；</p>
<p>索引和数据行的长度；</p>
<p>索引的分布情况；</p>
<h5 id="在很多情况下mysql会选择错误的执行计划，原因如下："><a href="#在很多情况下mysql会选择错误的执行计划，原因如下：" class="headerlink" title="在很多情况下mysql会选择错误的执行计划，原因如下："></a>在很多情况下mysql会选择错误的执行计划，原因如下：</h5><p>1.统计信息不准确：</p>
<p>InnoDB因为其mvcc的架构，并不能维护一个数据表的行数的精确统计信息</p>
<p>2.执行计划的成本估算不等同于实际执行的成本：</p>
<p>有时候某个执行计划虽然需要读取更多的页面，但是他的成本却更小，因为如果这些页面都是顺序读或者这些页面都已经在内存中的话，那么它的访问成本将很小，mysql层面并不知道哪些页面在内存中，哪些在磁盘，所以查询之际执行过程中到底需要多少次IO是无法得知的</p>
<p>3.mysql的最优可能跟你想的不一样：</p>
<p>mysql的优化是基于成本模型的优化，但是有可能不是最快的优化。</p>
<p>4.mysql不考虑其他并发执行的查询：</p>
<p>5.mysql不会考虑不受其控制的操作成本：</p>
<p>执行存储过程或者用户自定义函数的成本。</p>
<h5 id="优化器的优化策略"><a href="#优化器的优化策略" class="headerlink" title="优化器的优化策略"></a>优化器的优化策略</h5><p>静态优化：</p>
<p>直接对解析树进行分析，并完成优化。</p>
<p>动态优化：</p>
<p>动态优化与查询的上下文有关，也可能跟取值、索引对应的行数有关</p>
<p>mysql对查询的静态优化只需要一次，但对动态优化在每次执行时都需要重新评估</p>
<h5 id="优化器的优化类型"><a href="#优化器的优化类型" class="headerlink" title="优化器的优化类型"></a>优化器的优化类型</h5><p>1.重新定义关联表的顺序：</p>
<p>数据表的关联并不总是按照在查询中指定的顺序进行，决定关联顺序时优化器很重要的功能</p>
<p>2.将外连接转化成内连接，内连接的效率要高于外连接；</p>
<p>3.使用等价变换规则，mysql可以使用一些等价变化来简化并规划表达式</p>
<p>4.优化count(),min(),max()</p>
<p>索引和列是否可以为空通常可以帮助mysql优化这类表达式：例如，要找到某一列的最小值，只需要查询索引的最左端的记录即可，不需要全文扫描比较</p>
<p>5.预估并转化为常数表达式，当mysql检测到一个表达式可以转化为常数的时候，就会一直把该表达式作为常数进行处理</p>
<p>explain select film.film_id,film_actor.actor_id from film inner join film_actor using(film_id) where film.film_id &#x3D; 1</p>
<p>6.索引覆盖扫描，当索引中的列包含所有查询中需要使用的列的时候，可以使用覆盖索引</p>
<p>7.子查询优化</p>
<p>mysql在某些情况下可以将子查询转换一种效率更高的形式，从而减少多个查询多次对数据进行访问，例如将经常查询的数据放入到缓存中</p>
<p>8.等值传播</p>
<p>如果两个列的值通过等式关联，那么mysql能够把其中一个列的where条件传递到另一个上：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> film.film_id <span class="hljs-keyword">from</span> film <br><span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> film_actor <span class="hljs-keyword">using</span>(film_id) <br><span class="hljs-keyword">where</span> film.film_id <span class="hljs-operator">&gt;</span> <span class="hljs-number">500</span>;<br></code></pre></td></tr></table></figure>


<p>这里使用film_id字段进行等值关联，film_id这个列不仅适用于film表而且适用于film_actor表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> film.film_id <span class="hljs-keyword">from</span> film <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> film_actor <span class="hljs-keyword">using</span>(film_id) <span class="hljs-keyword">where</span> film.film_id <span class="hljs-operator">&gt;</span> <span class="hljs-number">500</span> <span class="hljs-keyword">and</span> film_actor.film_id <span class="hljs-operator">&gt;</span> <span class="hljs-number">500</span>;<br></code></pre></td></tr></table></figure>

<h3 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h3><p>join的实现方式原理</p>
<p>Simple Nested-Loop Join：</p>
<p><img src="/.com//simpleNestedLoopJoin.png" srcset="/img/loading.gif" lazyload alt="simpleNestedLoopJoin"></p>
<p>Index Nested-Loop Join:</p>
<p><img src="/.com//indexNestedLoopJoin.png" srcset="/img/loading.gif" lazyload alt="indexNestedLoopJoin"></p>
<p>Block Nested-Loop Join:</p>
<p><img src="/.com//blockNestedLoopJoin.png" srcset="/img/loading.gif" lazyload alt="blockNestedLoopJoin"></p>
<p>（1）Join Buffer会缓存所有参与查询的列而不是只有Join的列。<br>（2）可以通过调整join_buffer_size缓存大小<br>（3）join_buffer_size的默认值是256K，join_buffer_size的最大值在MySQL 5.1.22版本前是4G-1，而之后的版本才能在64位操作系统下申请大于4G的Join Buffer空间。<br>（4）使用Block Nested-Loop Join算法需要开启优化器管理配置的optimizer_switch的设置block_nested_loop为on，默认为开启。</p>
<p>show variables like ‘%optimizer_switch%’</p>
<p>查看不同的顺序执行方式对查询性能的影响：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> film.film_id,film.title,film.release_year,actor.actor_id,actor.first_name,actor.last_name <span class="hljs-keyword">from</span> film <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> film_actor <span class="hljs-keyword">using</span>(film_id) <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> actor <span class="hljs-keyword">using</span>(actor_id);<br>查看执行的成本：<br><span class="hljs-keyword">show</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;last_query_cost&#x27;</span>; <br>按照自己预想的规定顺序执行：<br>explain <span class="hljs-keyword">select</span> straight_join film.film_id,film.title,film.release_year,actor.actor_id,actor.first_name,actor.last_name <span class="hljs-keyword">from</span> film <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> film_actor <span class="hljs-keyword">using</span>(film_id) <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> actor <span class="hljs-keyword">using</span>(actor_id);<br>查看执行的成本：<br><span class="hljs-keyword">show</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;last_query_cost&#x27;</span>; <br></code></pre></td></tr></table></figure>

<h3 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h3><p>无论如何排序都是一个成本很高的操作，所以从性能的角度出发，应该尽可能避免排序或者尽可能避免对大量数据进行排序。<br>推荐使用利用索引进行排序，但是当不能使用索引的时候，mysql就需要自己进行排序，如果数据量小则再内存中进行，如果数据量大就需要使用磁盘，mysql中称之为filesort。<br>如果需要排序的数据量小于排序缓冲区(show variables like ‘%sort_buffer_size%’;),mysql使用内存进行快速排序操作，如果内存不够排序，那么mysql就会先将树分块，对每个独立的块使用快速排序进行排序，并将各个块的排序结果存放再磁盘上，然后将各个排好序的块进行合并，最后返回排序结果。</p>
<p>排序的算法：</p>
<ol>
<li>两次传输排序:</li>
</ol>
<p>第一次数据读取是将需要排序的字段读取出来，然后进行排序，第二次是将排好序的结果按照需要去读取数据行。<br>这种方式效率比较低，原因是第二次读取数据的时候因为已经排好序，需要去读取所有记录而此时更多的是随机IO，读取数据成本会比较高<br>两次传输的优势，在排序的时候存储尽可能少的数据，让排序缓冲区可以尽可能多的容纳行数来进行排序操作</p>
<ol start="2">
<li>单次传输排序</li>
</ol>
<p>先读取查询所需要的所有列，然后再根据给定列进行排序，最后直接返回排序结果，此方式只需要一次顺序IO读取所有的数据，而无须任何的随机IO，问题在于查询的列特别多的时候，会占用大量的存储空间，无法存储大量的数据</p>
<p>当需要排序的列的总大小超过max_length_for_sort_data定义的字节，mysql会选择双次排序，反之使用单次排序，当然，用户可以设置此参数的值来选择排序的方式。</p>
<h3 id="优化特定类型的查询"><a href="#优化特定类型的查询" class="headerlink" title="优化特定类型的查询"></a>优化特定类型的查询</h3><h4 id="优化count-查询"><a href="#优化count-查询" class="headerlink" title="优化count()查询"></a>优化count()查询</h4><p>count()是特殊的函数，有两种不同的作用，一种是某个列值的数量，也可以统计行数。</p>
<p>1.总有人认为myisam的count函数比较快，这是有前提条件的，只有没有任何where条件的count(*)才是比较快的</p>
<p>2.使用近似值：</p>
<p>在某些应用场景中，不需要完全精确的值，可以参考使用近似值来代替，比如可以使用explain来获取近似的值<br>其实在很多OLAP的应用中，需要计算某一个列值的基数，有一个计算近似值的算法叫hyperloglog。</p>
<p>3.更复杂的优化</p>
<p>一般情况下，count()需要扫描大量的行才能获取精确的数据，其实很难优化，在实际操作的时候可以考虑使用索引覆盖扫描，或者增加汇总表，或者增加外部缓存系统。</p>
<p>测试：</p>
<p>深分页问题</p>
<p>select id,name from test where create_time &gt;&#x3D; ‘2022-07-09 00:00:00’ limit 0, 10</p>
<p>select id,name from test where create_time &gt;&#x3D; ‘2022-07-09 00:00:00’ limit 100000, 10</p>
<ol>
<li>子查询优化</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,name <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;=</span> <br>(<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> create_time <span class="hljs-operator">&gt;=</span> <span class="hljs-string">&#x27;2022-07-09 00:00:00&#x27;</span> limit <span class="hljs-number">1</span>) <br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id<br>limit  <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>偏移法</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,name <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;=</span> <span class="hljs-number">100000</span><br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id<br>limit <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>

<h4 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h4><p>1.确保on或者using子句中的列上有索引，在创建索引的时候就要考虑到关联的顺序。</p>
<p>当表A和表B使用列C关联的时候，如果优化器的关联顺序是B、A，那么就不需要再B表的对应列上建上索引，没有用到的索引只会带来额外的负担，一般情况下来说，只需要在关联顺序中的第二个表的相应列上创建索引</p>
<p>2.确保任何的groupby和order by中的表达式只涉及到一个表中的列，这样mysql才有可能使用索引来优化这个过程</p>
<h4 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h4><p>子查询的优化最重要的优化建议是尽可能使用关联查询代替</p>
<h4 id="优化limit分页"><a href="#优化limit分页" class="headerlink" title="优化limit分页"></a>优化limit分页</h4><p>在很多应用场景中我们需要将数据进行分页，一般会使用limit加上偏移量的方法实现，同时加上合适的orderby 的子句，如果这种方式有索引的帮助，效率通常不错，否则的化需要进行大量的文件排序操作，还有一种情况，当偏移量非常大的时候，前面的大部分数据都会被抛弃，这样的代价太高。<br>要优化这种查询的话，要么是在页面中限制分页的数量，要么优化大偏移量的性能</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> film_id,description <span class="hljs-keyword">from</span> film <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> title limit <span class="hljs-number">50</span>,<span class="hljs-number">5</span><br><br><span class="hljs-comment">-- 查看执行计划查看扫描的行数</span><br>explain <br><span class="hljs-keyword">select</span> film.film_id,film.description <span class="hljs-keyword">from</span> film <br><span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> (<span class="hljs-keyword">select</span> film_id <span class="hljs-keyword">from</span> film <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> title limit <span class="hljs-number">50</span>,<span class="hljs-number">5</span>) <span class="hljs-keyword">as</span> lim <span class="hljs-keyword">using</span>(film_id);<br></code></pre></td></tr></table></figure>

<h4 id="优化union查询"><a href="#优化union查询" class="headerlink" title="优化union查询"></a>优化union查询</h4><p>除非确实需要服务器消除重复的行，否则一定要使用union all，因此没有all关键字，mysql会在查询的时候给临时表加上distinct的关键字，这个操作的代价很高</p>
<h4 id="推荐使用用户自定义变量"><a href="#推荐使用用户自定义变量" class="headerlink" title="推荐使用用户自定义变量"></a>推荐使用用户自定义变量</h4><p>用户自定义变量是一个容易被遗忘的mysql特性，但是如果能够用好，在某些场景下可以写出非常高效的查询语句，在查询中混合使用过程化和关系化逻辑的时候，自定义变量会非常有用。<br>用户自定义变量是一个用来存储内容的临时容器，在连接mysql的整个过程中都存在。</p>
<h5 id="自定义变量的使用"><a href="#自定义变量的使用" class="headerlink" title="自定义变量的使用"></a>自定义变量的使用</h5><p>set @one :&#x3D;1</p>
<p>set @min_actor :&#x3D;(select min(actor_id) from actor)</p>
<p>set @last_week :&#x3D;current_date-interval 1 week;</p>
<h5 id="自定义变量的限制"><a href="#自定义变量的限制" class="headerlink" title="自定义变量的限制"></a>自定义变量的限制</h5><p>1、无法使用查询缓存</p>
<p>2、不能在使用常量或者标识符的地方使用自定义变量，例如表名、列名或者limit子句</p>
<p>3、用户自定义变量的生命周期是在一个连接中有效，所以不能用它们来做连接间的通信</p>
<p>4、不能显式地声明自定义变量地类型</p>
<p>5、mysql优化器在某些场景下可能会将这些变量优化掉，这可能导致代码不按预想地方式运行</p>
<p>6、赋值符号：&#x3D;的优先级非常低，所以在使用赋值表达式的时候应该明确的使用括号</p>
<p>7、使用未定义变量不会产生任何语法错误</p>
<h5 id="自定义变量的使用案例"><a href="#自定义变量的使用案例" class="headerlink" title="自定义变量的使用案例"></a>自定义变量的使用案例</h5><p>优化排名语句</p>
<p>1、在给一个变量赋值的同时使用这个变量</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> actor_id,<span class="hljs-variable">@rownum</span>:<span class="hljs-operator">=</span><span class="hljs-variable">@rownum</span><span class="hljs-operator">+</span><span class="hljs-number">1</span> <span class="hljs-keyword">as</span> rownum <span class="hljs-keyword">from</span> actor limit <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>

<p>2、查询获取演过最多电影的前10名演员，然后根据出演电影次数做一个排名</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> actor_id,<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> cnt <span class="hljs-keyword">from</span> film_actor <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> actor_id <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> cnt <span class="hljs-keyword">desc</span> limit <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>

<h5 id="避免重新查询刚刚更新的数据"><a href="#避免重新查询刚刚更新的数据" class="headerlink" title="避免重新查询刚刚更新的数据"></a>避免重新查询刚刚更新的数据</h5><p>当需要高效的更新一条记录的时间戳，同时希望查询当前记录中存放的时间戳是什么。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> t1 <span class="hljs-keyword">set</span>  lastUpdated<span class="hljs-operator">=</span>now() <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br><span class="hljs-keyword">select</span> lastUpdated <span class="hljs-keyword">from</span> t1 <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">update</span> t1 <span class="hljs-keyword">set</span> lastupdated <span class="hljs-operator">=</span> now() <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-variable">@now</span>:<span class="hljs-operator">=</span>now();<br><span class="hljs-keyword">select</span> <span class="hljs-variable">@now</span>;<br></code></pre></td></tr></table></figure>

<h5 id="确定取值的顺序"><a href="#确定取值的顺序" class="headerlink" title="确定取值的顺序"></a>确定取值的顺序</h5><p>在赋值和读取变量的时候可能是在查询的不同阶段</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-variable">@rownum</span>:<span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br><span class="hljs-keyword">select</span> actor_id,<span class="hljs-variable">@rownum</span>:<span class="hljs-operator">=</span><span class="hljs-variable">@rownum</span><span class="hljs-operator">+</span><span class="hljs-number">1</span> <span class="hljs-keyword">as</span> cnt <span class="hljs-keyword">from</span> actor <span class="hljs-keyword">where</span> <span class="hljs-variable">@rownum</span><span class="hljs-operator">&lt;=</span><span class="hljs-number">1</span>;<br>因为<span class="hljs-keyword">where</span>和<span class="hljs-keyword">select</span>在查询的不同阶段执行，所以看到查询到两条记录，这不符合预期<br><br><span class="hljs-keyword">set</span> <span class="hljs-variable">@rownum</span>:<span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br><span class="hljs-keyword">select</span> actor_id,<span class="hljs-variable">@rownum</span>:<span class="hljs-operator">=</span><span class="hljs-variable">@rownum</span><span class="hljs-operator">+</span><span class="hljs-number">1</span> <span class="hljs-keyword">as</span> cnt <span class="hljs-keyword">from</span> actor <span class="hljs-keyword">where</span> <span class="hljs-variable">@rownum</span><span class="hljs-operator">&lt;=</span><span class="hljs-number">1</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> first_name<br>当引入了<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span>之后，发现打印出了全部结果，这是因为<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span>引入了文件排序，而<span class="hljs-keyword">where</span>条件是在文件排序操作之前取值的  <br><br>解决这个问题的关键在于让变量的赋值和取值发生在执行查询的同一阶段：<br><span class="hljs-keyword">set</span> <span class="hljs-variable">@rownum</span>:<span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br><span class="hljs-keyword">select</span> actor_id,<span class="hljs-variable">@rownum</span> <span class="hljs-keyword">as</span> cnt <span class="hljs-keyword">from</span> actor <span class="hljs-keyword">where</span> (<span class="hljs-variable">@rownum</span>:<span class="hljs-operator">=</span><span class="hljs-variable">@rownum</span><span class="hljs-operator">+</span><span class="hljs-number">1</span>)<span class="hljs-operator">&lt;=</span><span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<h1 id="通过索引进行优化"><a href="#通过索引进行优化" class="headerlink" title="通过索引进行优化"></a>通过索引进行优化</h1><h2 id="索引基本知识"><a href="#索引基本知识" class="headerlink" title="索引基本知识"></a>索引基本知识</h2><h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><p>1、大大减少了服务器需要扫描的数据量</p>
<p>2、帮助服务器避免排序和临时表</p>
<p>3、将随机io变成顺序io</p>
<h3 id="索引的用处"><a href="#索引的用处" class="headerlink" title="索引的用处"></a>索引的用处</h3><p>1、快速查找匹配WHERE子句的行</p>
<p>2、从consideration中消除行,如果可以在多个索引之间进行选择，mysql通常会使用找到最少行的索引</p>
<p>3、如果表具有多列索引，则优化器可以使用索引的任何最左前缀来查找行</p>
<p>4、当有表连接的时候，从其他表检索行数据</p>
<p>5、查找特定索引列的min或max值</p>
<p>6、如果排序或分组时在可用索引的最左前缀上完成的，则对表进行排序和分组</p>
<p>7、在某些情况下，可以优化查询以检索值而无需查询数据行</p>
<h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><p>主键索引</p>
<p>唯一索引</p>
<p>普通索引</p>
<p>全文索引</p>
<p>组合索引</p>
<h3 id="索引特性"><a href="#索引特性" class="headerlink" title="索引特性"></a>索引特性</h3><p>覆盖索引</p>
<p>最左匹配</p>
<p>索引下推</p>
<h3 id="索引采用的数据结构"><a href="#索引采用的数据结构" class="headerlink" title="索引采用的数据结构"></a>索引采用的数据结构</h3><p>哈希表</p>
<p>B+树</p>
<h3 id="索引匹配方式"><a href="#索引匹配方式" class="headerlink" title="索引匹配方式"></a>索引匹配方式</h3><p>全值匹配：全值匹配指的是和索引中的所有列进行匹配</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> staffs <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;July&#x27;</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;23&#x27;</span> <span class="hljs-keyword">and</span> pos <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;dev&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>匹配最左前缀:只匹配前面的几列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> staffs <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;July&#x27;</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;23&#x27;</span>;<br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> staffs <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;July&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>匹配列前缀:可以匹配某一列的值的开头部分</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> staffs <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;J%&#x27;</span>;<br><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> staffs <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%y&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>匹配范围值:可以查找某一个范围的数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> staffs <span class="hljs-keyword">where</span> name <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;Mary&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>精确匹配某一列并范围匹配另外一列:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 可以查询第一列的全部和第二列的部分</span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> staffs <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;July&#x27;</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">25</span>;<br></code></pre></td></tr></table></figure>

<p>只访问索引的查询:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询的时候只需要访问索引，不需要访问数据行，本质上就是覆盖索引</span><br>explain <span class="hljs-keyword">select</span> name,age,pos <span class="hljs-keyword">from</span> staffs <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;July&#x27;</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">=</span> <span class="hljs-number">25</span> <span class="hljs-keyword">and</span> pos <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;dev&#x27;</span>;<br></code></pre></td></tr></table></figure>

<h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p>基于哈希表的实现，只有精确匹配索引所有列的查询才有效</p>
<p>在mysql中，只有memory的存储引擎显式支持哈希索引</p>
<p>哈希索引自身只需存储对应的hash值，所以索引的结构十分紧凑，这让哈希索引查找的速度非常快</p>
<h3 id="哈希索引的限制"><a href="#哈希索引的限制" class="headerlink" title="哈希索引的限制"></a>哈希索引的限制</h3><p>1、哈希索引只包含哈希值和行指针，而不存储字段值，索引不能使用索引中的值来避免读取行</p>
<p>2、哈希索引数据并不是按照索引值顺序存储的，所以无法进行排序</p>
<p>3、哈希索引不支持部分列匹配查找，哈希索引是使用索引列的全部内容来计算哈希值</p>
<p>4、哈希索引支持等值比较查询，也不支持任何范围查询</p>
<p>5、访问哈希索引的数据非常快，除非有很多哈希冲突，当出现哈希冲突的时候，存储引擎必须遍历链表中的所有行指针，逐行进行比较，直到找到所有符合条件的行</p>
<p>6、哈希冲突比较多的话，维护的代价也会很高</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>当需要存储大量的URL，并且根据URL进行搜索查找，如果使用B+树，存储的内容就会很大<br>select id from url where url&#x3D;””<br>也可以利用将url使用CRC32做哈希，可以使用以下查询方式：<br>select id fom url where url&#x3D;”” and url_crc&#x3D;CRC32(“”)<br>此查询性能较高原因是使用体积很小的索引来完成查找</p>
<h2 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h2><p>当包含多个列作为索引，需要注意的是正确的顺序依赖于该索引的查询，同时需要考虑如何更好的满足排序和分组的需要</p>
<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>建立组合索引a,b,c</p>
<p>不同SQL语句使用索引情况</p>
<p><img src="/.com//%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E6%83%85%E5%86%B5.png" srcset="/img/loading.gif" lazyload alt="组合索引测试使用索引情况"></p>
<h2 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h2><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>不是单独的索引类型，而是一种数据存储方式，指的是数据行跟相邻的键值紧凑的存储在一起</p>
<p>优点：</p>
<p>1、可以把相关数据保存在一起</p>
<p>2、数据访问更快，因为索引和数据保存在同一个树中</p>
<p>3、使用覆盖索引扫描的查询可以直接使用页节点中的主键值</p>
<p>缺点：</p>
<p>1、聚簇数据最大限度地提高了IO密集型应用的性能，如果数据全部在内存，那么聚簇索引就没有什么优势</p>
<p>2、插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式</p>
<p>3、更新聚簇索引列的代价很高，因为会强制将每个被更新的行移动到新的位置</p>
<p>4、基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临页分裂的问题</p>
<p>5、聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候</p>
<h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><p>数据文件跟索引文件分开存放</p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1、如果一个索引包含所有需要查询的字段的值，我们称之为覆盖索引</p>
<p>2、不是所有类型的索引都可以称为覆盖索引，覆盖索引必须要存储索引列的值</p>
<p>3、不同的存储实现覆盖索引的方式不同，不是所有的引擎都支持覆盖索引，memory不支持覆盖索引</p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>1、索引条目通常远小于数据行大小，如果只需要读取索引，那么mysql就会极大的较少数据访问量</p>
<p>2、因为索引是按照列值顺序存储的，所以对于IO密集型的范围查询会比随机从磁盘读取每一行数据的IO要少的多</p>
<p>3、一些存储引擎如MYISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用，这可能会导致严重的性能问题</p>
<p>4、由于INNODB的聚簇索引，覆盖索引对INNODB表特别有用</p>
<h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><p>1、当发起一个被索引覆盖的查询时，在explain的extra列可以看到using index的信息，此时就使用了覆盖索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> store_id,film_id <span class="hljs-keyword">from</span> inventory\G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: inventory<br>   partitions: <span class="hljs-keyword">NULL</span><br>         type: index<br>possible_keys: <span class="hljs-keyword">NULL</span><br>          key: idx_store_id_film_id<br>      key_len: <span class="hljs-number">3</span><br>          <span class="hljs-keyword">ref</span>: <span class="hljs-keyword">NULL</span><br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">4581</span><br>     filtered: <span class="hljs-number">100.00</span><br>        Extra: <span class="hljs-keyword">Using</span> index<br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.01</span> sec)<br><br></code></pre></td></tr></table></figure>

<p>2、在大多数存储引擎中，覆盖索引只能覆盖那些只访问索引中部分列的查询。不过，可以进一步的进行优化，可以使用innodb的二级索引来覆盖查询。</p>
<p>例如：actor使用innodb存储引擎，并在last_name字段又二级索引，虽然该索引的列不包括主键actor_id，但也能够用于对actor_id做覆盖查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> actor_id,last_name <span class="hljs-keyword">from</span> actor <span class="hljs-keyword">where</span> last_name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;HOPPER&#x27;</span>\G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: actor<br>   partitions: <span class="hljs-keyword">NULL</span><br>         type: <span class="hljs-keyword">ref</span><br>possible_keys: idx_actor_last_name<br>          key: idx_actor_last_name<br>      key_len: <span class="hljs-number">137</span><br>          <span class="hljs-keyword">ref</span>: const<br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">2</span><br>     filtered: <span class="hljs-number">100.00</span><br>        Extra: <span class="hljs-keyword">Using</span> index<br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br><br></code></pre></td></tr></table></figure>

<h2 id="优化小细节"><a href="#优化小细节" class="headerlink" title="优化小细节"></a>优化小细节</h2><p>1.当使用索引列进行查询的时候尽量不要使用表达式，把计算放到业务层而不是数据库层</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> actor_id <span class="hljs-keyword">from</span> actor <span class="hljs-keyword">where</span> actor_id<span class="hljs-operator">=</span><span class="hljs-number">4</span>;<br><br><span class="hljs-keyword">select</span> actor_id <span class="hljs-keyword">from</span> actor <span class="hljs-keyword">where</span> actor_id<span class="hljs-operator">+</span><span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>

<p>2.尽量使用主键查询，而不是其他索引，因此主键查询不会触发回表查询</p>
<p>3.使用前缀索引</p>
<p>有时候需要索引很长的字符串，这会让索引变的大且慢，通常情况下可以使用某个列开始的部分字符串，这样大大的节约索引空间，从而提高索引效率，但这会降低索引的选择性，索引的选择性是指不重复的索引值和数据表记录总数的比值，范围从1&#x2F;#T到1之间。索引的选择性越高则查询效率越高，因为选择性更高的索引可以让mysql在查找的时候过滤掉更多的行。</p>
<p>​		一般情况下某个列前缀的选择性也是足够高的，足以满足查询的性能，但是对应BLOB,TEXT,VARCHAR类型的列，必须要使用前缀索引，因为mysql不允许索引这些列的完整长度，使用该方法的诀窍在于要选择足够长的前缀以保证较高的选择性，通过又不能太长。</p>
<p>测试：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--创建数据表</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> citydemo(city <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> citydemo(city) <span class="hljs-keyword">select</span> city <span class="hljs-keyword">from</span> city;<br><br><span class="hljs-comment">--重复执行5次下面的sql语句</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> citydemo(city) <span class="hljs-keyword">select</span> city <span class="hljs-keyword">from</span> citydemo;<br><br><span class="hljs-comment">--更新城市表的名称</span><br><span class="hljs-keyword">update</span> citydemo <span class="hljs-keyword">set</span> city<span class="hljs-operator">=</span>(<span class="hljs-keyword">select</span> city <span class="hljs-keyword">from</span> city <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> rand() limit <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">--查找最常见的城市列表，发现每个值都出现45-65次，</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> cnt,city <span class="hljs-keyword">from</span> citydemo <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> city <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> cnt <span class="hljs-keyword">desc</span> limit <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">--查找最频繁出现的城市前缀，先从3个前缀字母开始，发现比原来出现的次数更多，可以分别截取多个字符查看城市出现的次数</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> cnt,<span class="hljs-keyword">left</span>(city,<span class="hljs-number">3</span>) <span class="hljs-keyword">as</span> pref <span class="hljs-keyword">from</span> citydemo <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> pref <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> cnt <span class="hljs-keyword">desc</span> limit <span class="hljs-number">10</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> cnt,<span class="hljs-keyword">left</span>(city,<span class="hljs-number">7</span>) <span class="hljs-keyword">as</span> pref <span class="hljs-keyword">from</span> citydemo <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> pref <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> cnt <span class="hljs-keyword">desc</span> limit <span class="hljs-number">10</span>;<br><span class="hljs-comment">--此时前缀的选择性接近于完整列的选择性</span><br><br><span class="hljs-comment">--还可以通过另外一种方式来计算完整列的选择性，可以看到当前缀长度到达7之后，再增加前缀长度，选择性提升的幅度已经很小了</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-keyword">left</span>(city,<span class="hljs-number">3</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sel3,<br><span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-keyword">left</span>(city,<span class="hljs-number">4</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sel4,<br><span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-keyword">left</span>(city,<span class="hljs-number">5</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sel5,<br><span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-keyword">left</span>(city,<span class="hljs-number">6</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sel6,<br><span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-keyword">left</span>(city,<span class="hljs-number">7</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sel7,<br><span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-keyword">left</span>(city,<span class="hljs-number">8</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sel8 <br><span class="hljs-keyword">from</span> citydemo;<br><br><span class="hljs-comment">--计算完成之后可以创建前缀索引</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> citydemo <span class="hljs-keyword">add</span> key(city(<span class="hljs-number">7</span>));<br><br><span class="hljs-comment">--注意：前缀索引是一种能使索引更小更快的有效方法，但是也包含缺点：mysql无法使用前缀索引做order by 和 group by。 </span><br></code></pre></td></tr></table></figure>

<p>4.使用索引扫描来排序</p>
<p>ysql有两种方式可以生成有序的结果：通过排序操作或者按索引顺序扫描，如果explain出来的type列的值为index,则说明mysql使用了索引扫描来做排序</p>
<p>​		扫描索引本身是很快的，因为只需要从一条索引记录移动到紧接着的下一条记录。但如果索引不能覆盖查询所需的全部列，那么就不得不每扫描一条索引记录就得回表查询一次对应的行，这基本都是随机IO，因此按索引顺序读取数据的速度通常要比顺序地全表扫描慢</p>
<p>​		mysql可以使用同一个索引即满足排序，又用于查找行，如果可能的话，设计索引时应该尽可能地同时满足这两种任务。</p>
<p>​		只有当索引的列顺序和order by子句的顺序完全一致，并且所有列的排序方式都一样时，mysql才能够使用索引来对结果进行排序，如果查询需要关联多张表，则只有当orderby子句引用的字段全部为第一张表时，才能使用索引做排序。order by子句和查找型查询的限制是一样的，需要满足索引的最左前缀的要求，否则，mysql都需要执行顺序操作，而无法利用索引排序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--sakila数据库中rental表在rental_date,inventory_id,customer_id上有rental_date的索引</span><br><span class="hljs-comment">--使用rental_date索引为下面的查询做排序</span><br>explain <span class="hljs-keyword">select</span> rental_id,staff_id <span class="hljs-keyword">from</span> rental <span class="hljs-keyword">where</span> rental_date<span class="hljs-operator">=</span><span class="hljs-string">&#x27;2005-05-25&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> inventory_id,customer_id\G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: rental<br>   partitions: <span class="hljs-keyword">NULL</span><br>         type: <span class="hljs-keyword">ref</span><br>possible_keys: rental_date<br>          key: rental_date<br>      key_len: <span class="hljs-number">5</span><br>          <span class="hljs-keyword">ref</span>: const<br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">1</span><br>     filtered: <span class="hljs-number">100.00</span><br>        Extra: <span class="hljs-keyword">Using</span> index <span class="hljs-keyword">condition</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br><span class="hljs-comment">--order by子句不满足索引的最左前缀的要求，也可以用于查询排序，这是因为所以你的第一列被指定为一个常数</span><br><br><span class="hljs-comment">--该查询为索引的第一列提供了常量条件，而使用第二列进行排序，将两个列组合在一起，就形成了索引的最左前缀</span><br>explain <span class="hljs-keyword">select</span> rental_id,staff_id <span class="hljs-keyword">from</span> rental <span class="hljs-keyword">where</span> rental_date<span class="hljs-operator">=</span><span class="hljs-string">&#x27;2005-05-25&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> inventory_id <span class="hljs-keyword">desc</span>\G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: rental<br>   partitions: <span class="hljs-keyword">NULL</span><br>         type: <span class="hljs-keyword">ref</span><br>possible_keys: rental_date<br>          key: rental_date<br>      key_len: <span class="hljs-number">5</span><br>          <span class="hljs-keyword">ref</span>: const<br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">1</span><br>     filtered: <span class="hljs-number">100.00</span><br>        Extra: <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br><br><span class="hljs-comment">--下面的查询不会利用索引</span><br>explain <span class="hljs-keyword">select</span> rental_id,staff_id <span class="hljs-keyword">from</span> rental <span class="hljs-keyword">where</span> rental_date<span class="hljs-operator">&gt;</span><span class="hljs-string">&#x27;2005-05-25&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> rental_date,inventory_id\G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: rental<br>   partitions: <span class="hljs-keyword">NULL</span><br>         type: <span class="hljs-keyword">ALL</span><br>possible_keys: rental_date<br>          key: <span class="hljs-keyword">NULL</span><br>      key_len: <span class="hljs-keyword">NULL</span><br>          <span class="hljs-keyword">ref</span>: <span class="hljs-keyword">NULL</span><br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">16005</span><br>     filtered: <span class="hljs-number">50.00</span><br>        Extra: <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span>; <span class="hljs-keyword">Using</span> filesort<br><br><span class="hljs-comment">--该查询使用了两中不同的排序方向，但是索引列都是正序排序的</span><br>explain <span class="hljs-keyword">select</span> rental_id,staff_id <span class="hljs-keyword">from</span> rental <span class="hljs-keyword">where</span> rental_date<span class="hljs-operator">&gt;</span><span class="hljs-string">&#x27;2005-05-25&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> inventory_id <span class="hljs-keyword">desc</span>,customer_id <span class="hljs-keyword">asc</span>\G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: rental<br>   partitions: <span class="hljs-keyword">NULL</span><br>         type: <span class="hljs-keyword">ALL</span><br>possible_keys: rental_date<br>          key: <span class="hljs-keyword">NULL</span><br>      key_len: <span class="hljs-keyword">NULL</span><br>          <span class="hljs-keyword">ref</span>: <span class="hljs-keyword">NULL</span><br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">16005</span><br>     filtered: <span class="hljs-number">50.00</span><br>        Extra: <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span>; <span class="hljs-keyword">Using</span> filesort<br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br><br><span class="hljs-comment">--该查询中引用了一个不再索引中的列</span><br>explain <span class="hljs-keyword">select</span> rental_id,staff_id <span class="hljs-keyword">from</span> rental <span class="hljs-keyword">where</span> rental_date<span class="hljs-operator">&gt;</span><span class="hljs-string">&#x27;2005-05-25&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> inventory_id,staff_id\G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: rental<br>   partitions: <span class="hljs-keyword">NULL</span><br>         type: <span class="hljs-keyword">ALL</span><br>possible_keys: rental_date<br>          key: <span class="hljs-keyword">NULL</span><br>      key_len: <span class="hljs-keyword">NULL</span><br>          <span class="hljs-keyword">ref</span>: <span class="hljs-keyword">NULL</span><br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">16005</span><br>     filtered: <span class="hljs-number">50.00</span><br>        Extra: <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span>; <span class="hljs-keyword">Using</span> filesort<br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure>

<p>5.union all,in,or都能够使用索引，但是推荐使用in</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> actor <span class="hljs-keyword">where</span> actor_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> actor <span class="hljs-keyword">where</span> actor_id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> actor <span class="hljs-keyword">where</span> actor_id <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> actor <span class="hljs-keyword">where</span> actor_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> actor_id <span class="hljs-operator">=</span><span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure>

<p>6.范围列可以用到索引</p>
<p>范围条件是：&lt;、&gt;</p>
<p>范围列可以用到索引，但是范围列后面的列无法用到索引，索引最多用于一个范围列</p>
<p>7.强制类型转换会全表扫描</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span>(id <span class="hljs-type">int</span>,name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),phone <span class="hljs-type">varchar</span>(<span class="hljs-number">11</span>));<br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">add</span> index idx_1(phone);<br><br><span class="hljs-comment">-- 不会触发索引</span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> phone<span class="hljs-operator">=</span><span class="hljs-number">13800001234</span>;<br><br><span class="hljs-comment">-- 触发索引</span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> phone<span class="hljs-operator">=</span><span class="hljs-string">&#x27;13800001234&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>8.更新十分频繁，数据区分度不高的字段上不宜建立索引</p>
<p>更新会变更B+树，更新频繁的字段建议索引会大大降低数据库性能</p>
<p>类似于性别这类区分不大的属性，建立索引是没有意义的，不能有效的过滤数据，</p>
<p>一般区分度在80%以上的时候就可以建立索引，区分度可以使用 count(distinct(列名))&#x2F;count(*) 来计算</p>
<p>9.创建索引的列，不允许为null，可能会得到不符合预期的结果</p>
<p>10.当需要进行表连接的时候，最好不要超过三张表，因为需要join的字段，数据类型必须一致</p>
<p>11.能使用limit的时候尽量使用limit</p>
<p>12.单表索引建议控制在5个以内</p>
<p>13.单索引字段数不允许超过5个（组合索引）</p>
<p>14.创建索引的时候应该避免以下错误概念</p>
<p>索引越多越好</p>
<p>过早优化，在不了解系统的情况下进行优化</p>
<h2 id="索引监控"><a href="#索引监控" class="headerlink" title="索引监控"></a>索引监控</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;Handler_read%&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>参数解释:</p>
<p>Handler_read_first：读取索引第一个条目的次数</p>
<p>Handler_read_key：通过index获取数据的次数</p>
<p>Handler_read_last：读取索引最后一个条目的次数</p>
<p>Handler_read_next：通过索引读取下一条数据的次数</p>
<p>Handler_read_prev：通过索引读取上一条数据的次数</p>
<p>Handler_read_rnd：从固定位置读取数据的次数</p>
<p>Handler_read_rnd_next：从数据节点读取下一条数据的次数</p>
<h2 id="索引优化测试"><a href="#索引优化测试" class="headerlink" title="索引优化测试"></a>索引优化测试</h2><p>预先准备好数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> FOREIGN_KEY_CHECKS<span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `itdragon_order_list`;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `itdragon_order_list` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;主键id，默认自增长&#x27;</span>,<br>  `transaction_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">150</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;交易号&#x27;</span>,<br>  `gross` <span class="hljs-keyword">double</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;毛收入(RMB)&#x27;</span>,<br>  `net` <span class="hljs-keyword">double</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;净收入(RMB)&#x27;</span>,<br>  `stock_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;发货仓库&#x27;</span>,<br>  `order_status` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;订单状态&#x27;</span>,<br>  `descript` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;客服备注&#x27;</span>,<br>  `finance_descript` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;财务备注&#x27;</span>,<br>  `create_type` <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;创建类型&#x27;</span>,<br>  `order_level` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;订单级别&#x27;</span>,<br>  `input_user` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;录入人&#x27;</span>,<br>  `input_date` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;录入时间&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">10003</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> itdragon_order_list <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;10000&#x27;</span>, <span class="hljs-string">&#x27;81X97310V32236260E&#x27;</span>, <span class="hljs-string">&#x27;6.6&#x27;</span>, <span class="hljs-string">&#x27;6.13&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-string">&#x27;ok&#x27;</span>, <span class="hljs-string">&#x27;ok&#x27;</span>, <span class="hljs-string">&#x27;auto&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;itdragon&#x27;</span>, <span class="hljs-string">&#x27;2017-08-28 17:01:49&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> itdragon_order_list <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;10001&#x27;</span>, <span class="hljs-string">&#x27;61525478BB371361Q&#x27;</span>, <span class="hljs-string">&#x27;18.88&#x27;</span>, <span class="hljs-string">&#x27;18.79&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-string">&#x27;ok&#x27;</span>, <span class="hljs-string">&#x27;ok&#x27;</span>, <span class="hljs-string">&#x27;auto&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;itdragon&#x27;</span>, <span class="hljs-string">&#x27;2017-08-18 17:01:50&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> itdragon_order_list <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;10002&#x27;</span>, <span class="hljs-string">&#x27;5RT64180WE555861V&#x27;</span>, <span class="hljs-string">&#x27;20.18&#x27;</span>, <span class="hljs-string">&#x27;20.17&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-string">&#x27;ok&#x27;</span>, <span class="hljs-string">&#x27;ok&#x27;</span>, <span class="hljs-string">&#x27;auto&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;itdragon&#x27;</span>, <span class="hljs-string">&#x27;2017-09-08 17:01:49&#x27;</span>);<br><br></code></pre></td></tr></table></figure>

<p>逐步开始进行优化：</p>
<p>第一个案例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> itdragon_order_list <span class="hljs-keyword">where</span> transaction_id <span class="hljs-operator">=</span> &quot;81X97310V32236260E&quot;;<br><span class="hljs-comment">--通过查看执行计划发现type=all,需要进行全表扫描</span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> itdragon_order_list <span class="hljs-keyword">where</span> transaction_id <span class="hljs-operator">=</span> &quot;81X97310V32236260E&quot;;<br><br><span class="hljs-comment">--优化一、为transaction_id创建唯一索引</span><br> <span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index idx_order_transaID <span class="hljs-keyword">on</span> itdragon_order_list (transaction_id);<br><span class="hljs-comment">--当创建索引之后，唯一索引对应的type是const，通过索引一次就可以找到结果，普通索引对应的type是ref，表示非唯一性索引赛秒，找到值还要进行扫描，直到将索引文件扫描完为止，显而易见，const的性能要高于ref</span><br> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> itdragon_order_list <span class="hljs-keyword">where</span> transaction_id <span class="hljs-operator">=</span> &quot;81X97310V32236260E&quot;;<br> <br> <span class="hljs-comment">--优化二、使用覆盖索引，查询的结果变成 transaction_id,当extra出现using index,表示使用了覆盖索引</span><br> explain <span class="hljs-keyword">select</span> transaction_id <span class="hljs-keyword">from</span> itdragon_order_list <span class="hljs-keyword">where</span> transaction_id <span class="hljs-operator">=</span> &quot;81X97310V32236260E&quot;;<br></code></pre></td></tr></table></figure>

<p>第二个案例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--创建复合索引</span><br><span class="hljs-keyword">create</span> index idx_order_levelDate <span class="hljs-keyword">on</span> itdragon_order_list (order_level,input_date);<br><br><span class="hljs-comment">--创建索引之后发现跟没有创建索引一样，都是全表扫描，都是文件排序</span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> itdragon_order_list <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> order_level,input_date;<br><br><span class="hljs-comment">--可以使用force index强制指定索引</span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> itdragon_order_list force index(idx_order_levelDate) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> order_level,input_date;<br><span class="hljs-comment">--其实给订单排序意义不大，给订单级别添加索引意义也不大，因此可以先确定order_level的值，然后再给input_date排序</span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> itdragon_order_list <span class="hljs-keyword">where</span> order_level<span class="hljs-operator">=</span><span class="hljs-number">3</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> input_date;<br></code></pre></td></tr></table></figure>

<h1 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h1><h2 id="分区表的应用场景"><a href="#分区表的应用场景" class="headerlink" title="分区表的应用场景"></a>分区表的应用场景</h2><p>1.表非常大以至于无法全部都放在内存中，或者只在表的最后部分有热点数据，其他均是历史数据</p>
<p>2.分区表的数据更容易维护：</p>
<p>​	批量删除大量数据可以使用清除整个分区的方式</p>
<p>​	对一个独立分区进行优化、检查、修复等操作</p>
<p>3.分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备</p>
<p>4.可以使用分区表来避免某些特殊的瓶颈</p>
<p>​	innodb的单个索引的互斥访问</p>
<p>​	ext3文件系统的inode锁竞争</p>
<p>5.可以备份和恢复独立的分区</p>
<h2 id="分区表的限制"><a href="#分区表的限制" class="headerlink" title="分区表的限制"></a>分区表的限制</h2><p>一个表最多只能有1024个分区，在5.7版本的时候可以支持8196个分区</p>
<p>在早期的mysql中，分区表达式必须是整数或者是返回整数的表达式，在mysql5.5中，某些场景可以直接使用列来进行分区</p>
<p>如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来</p>
<p>分区表无法使用外键约束</p>
<h2 id="分区表的原理"><a href="#分区表的原理" class="headerlink" title="分区表的原理"></a>分区表的原理</h2><p>​		分区表由多个相关的底层表实现，这个底层表也是由句柄对象标识，我们可以直接访问各个分区。存储引擎管理分区的各个底层表和管理普通表一样（所有的底层表都必须使用相同的存储引擎），分区表的索引知识在各个底层表上各自加上一个完全相同的索引。从存储引擎的角度来看，底层表和普通表没有任何不同，存储引擎也无须知道这是一个普通表还是一个分区表的一部分。</p>
<p>​		分区表的操作按照以下的操作逻辑进行：</p>
<p>​		<strong>select查询</strong></p>
<p>​		当查询一个分区表的时候，分区层先打开并锁住所有的底层表，优化器先判断是否可以过滤部分分区，然后再调用对应的存储引擎接口访问各个分区的数据</p>
<p>​		<strong>insert操作</strong></p>
<p>​		当写入一条记录的时候，分区层先打开并锁住所有的底层表，然后确定哪个分区接受这条记录，再将记录写入对应底层表</p>
<p>​		<strong>delete操作</strong></p>
<p>​		当删除一条记录时，分区层先打开并锁住所有的底层表，然后确定数据对应的分区，最后对相应底层表进行删除操作</p>
<p>​		<strong>update操作</strong></p>
<p>​		当更新一条记录时，分区层先打开并锁住所有的底层表，mysql先确定需要更新的记录再哪个分区，然后取出数据并更新，再判断更新后的数据应该再哪个分区，最后对底层表进行写入操作，并对源数据所在的底层表进行删除操作</p>
<p>​		有些操作时支持过滤的，例如，当删除一条记录时，MySQL需要先找到这条记录，如果where条件恰好和分区表达式匹配，就可以将所有不包含这条记录的分区都过滤掉，这对update同样有效。如果是insert操作，则本身就是只命中一个分区，其他分区都会被过滤掉。mysql先确定这条记录属于哪个分区，再将记录写入对应得曾分区表，无须对任何其他分区进行操作</p>
<p>​		虽然每个操作都会“先打开并锁住所有的底层表”，但这并不是说分区表在处理过程中是锁住全表的，如果存储引擎能够自己实现行级锁，例如innodb，则会在分区层释放对应表锁。</p>
<h2 id="分区表的类型"><a href="#分区表的类型" class="headerlink" title="分区表的类型"></a>分区表的类型</h2><p>范围分区:</p>
<p>根据列值在给定范围内将行分配给分区</p>
<p>范围分区表的分区方式是：每个分区都包含行数据且分区的表达式在给定的范围内，分区的范围应该是连续的且不能重叠，可以使用values less than运算符来定义。</p>
<p>​		1、创建普通的表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> employees (<br>    id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    fname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>),<br>    lname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>),<br>    hired <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;1970-01-01&#x27;</span>,<br>    separated <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;9999-12-31&#x27;</span>,<br>    job_code <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    store_id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>);<br></code></pre></td></tr></table></figure>

<p>​		2、创建带分区的表，下面建表的语句是按照store_id来进行分区的，指定了4个分区</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> employees (<br>    id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    fname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>),<br>    lname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>),<br>    hired <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;1970-01-01&#x27;</span>,<br>    separated <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;9999-12-31&#x27;</span>,<br>    job_code <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    store_id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>)<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span> (store_id) (<br>    <span class="hljs-keyword">PARTITION</span> p0 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">6</span>),<br>    <span class="hljs-keyword">PARTITION</span> p1 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">11</span>),<br>    <span class="hljs-keyword">PARTITION</span> p2 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">16</span>),<br>    <span class="hljs-keyword">PARTITION</span> p3 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">21</span>)<br>);<br><span class="hljs-comment">--在当前的建表语句中可以看到，store_id的值在1-5的在p0分区，6-10的在p1分区，11-15的在p3分区，16-20的在p4分区，但是如果插入超过20的值就会报错，因为mysql不知道将数据放在哪个分区</span><br></code></pre></td></tr></table></figure>

<p>​		3、可以使用less than maxvalue来避免此种情况</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> employees (<br>    id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    fname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>),<br>    lname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>),<br>    hired <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;1970-01-01&#x27;</span>,<br>    separated <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;9999-12-31&#x27;</span>,<br>    job_code <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    store_id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>)<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span> (store_id) (<br>    <span class="hljs-keyword">PARTITION</span> p0 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">6</span>),<br>    <span class="hljs-keyword">PARTITION</span> p1 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">11</span>),<br>    <span class="hljs-keyword">PARTITION</span> p2 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">16</span>),<br>    <span class="hljs-keyword">PARTITION</span> p3 <span class="hljs-keyword">VALUES</span> LESS THAN MAXVALUE<br>);<br><span class="hljs-comment">--maxvalue表示始终大于等于最大可能整数值的整数值</span><br></code></pre></td></tr></table></figure>

<p>​		4、可以使用相同的方式根据员工的职务代码对表进行分区</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> employees (<br>    id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    fname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>),<br>    lname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>),<br>    hired <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;1970-01-01&#x27;</span>,<br>    separated <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;9999-12-31&#x27;</span>,<br>    job_code <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    store_id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>)<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span> (job_code) (<br>    <span class="hljs-keyword">PARTITION</span> p0 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">100</span>),<br>    <span class="hljs-keyword">PARTITION</span> p1 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">1000</span>),<br>    <span class="hljs-keyword">PARTITION</span> p2 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">10000</span>)<br>);<br></code></pre></td></tr></table></figure>

<p>​		5、可以使用date类型进行分区：如虚妄根据每个员工离开公司的年份进行划分，如year(separated)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> employees (<br>    id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    fname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>),<br>    lname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>),<br>    hired <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;1970-01-01&#x27;</span>,<br>    separated <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;9999-12-31&#x27;</span>,<br>    job_code <span class="hljs-type">INT</span>,<br>    store_id <span class="hljs-type">INT</span><br>)<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span> ( <span class="hljs-keyword">YEAR</span>(separated) ) (<br>    <span class="hljs-keyword">PARTITION</span> p0 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">1991</span>),<br>    <span class="hljs-keyword">PARTITION</span> p1 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">1996</span>),<br>    <span class="hljs-keyword">PARTITION</span> p2 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">2001</span>),<br>    <span class="hljs-keyword">PARTITION</span> p3 <span class="hljs-keyword">VALUES</span> LESS THAN MAXVALUE<br>);<br></code></pre></td></tr></table></figure>

<p>​		6、可以使用函数根据range的值来对表进行分区，如timestampunix_timestamp()</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> quarterly_report_status (<br>    report_id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    report_status <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    report_updated <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span><br>)<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span> ( UNIX_TIMESTAMP(report_updated) ) (<br>    <span class="hljs-keyword">PARTITION</span> p0 <span class="hljs-keyword">VALUES</span> LESS THAN ( UNIX_TIMESTAMP(<span class="hljs-string">&#x27;2008-01-01 00:00:00&#x27;</span>) ),<br>    <span class="hljs-keyword">PARTITION</span> p1 <span class="hljs-keyword">VALUES</span> LESS THAN ( UNIX_TIMESTAMP(<span class="hljs-string">&#x27;2008-04-01 00:00:00&#x27;</span>) ),<br>    <span class="hljs-keyword">PARTITION</span> p2 <span class="hljs-keyword">VALUES</span> LESS THAN ( UNIX_TIMESTAMP(<span class="hljs-string">&#x27;2008-07-01 00:00:00&#x27;</span>) ),<br>    <span class="hljs-keyword">PARTITION</span> p3 <span class="hljs-keyword">VALUES</span> LESS THAN ( UNIX_TIMESTAMP(<span class="hljs-string">&#x27;2008-10-01 00:00:00&#x27;</span>) ),<br>    <span class="hljs-keyword">PARTITION</span> p4 <span class="hljs-keyword">VALUES</span> LESS THAN ( UNIX_TIMESTAMP(<span class="hljs-string">&#x27;2009-01-01 00:00:00&#x27;</span>) ),<br>    <span class="hljs-keyword">PARTITION</span> p5 <span class="hljs-keyword">VALUES</span> LESS THAN ( UNIX_TIMESTAMP(<span class="hljs-string">&#x27;2009-04-01 00:00:00&#x27;</span>) ),<br>    <span class="hljs-keyword">PARTITION</span> p6 <span class="hljs-keyword">VALUES</span> LESS THAN ( UNIX_TIMESTAMP(<span class="hljs-string">&#x27;2009-07-01 00:00:00&#x27;</span>) ),<br>    <span class="hljs-keyword">PARTITION</span> p7 <span class="hljs-keyword">VALUES</span> LESS THAN ( UNIX_TIMESTAMP(<span class="hljs-string">&#x27;2009-10-01 00:00:00&#x27;</span>) ),<br>    <span class="hljs-keyword">PARTITION</span> p8 <span class="hljs-keyword">VALUES</span> LESS THAN ( UNIX_TIMESTAMP(<span class="hljs-string">&#x27;2010-01-01 00:00:00&#x27;</span>) ),<br>    <span class="hljs-keyword">PARTITION</span> p9 <span class="hljs-keyword">VALUES</span> LESS THAN (MAXVALUE)<br>);<br><span class="hljs-comment">--timestamp不允许使用任何其他涉及值的表达式</span><br></code></pre></td></tr></table></figure>

<p>基于时间间隔的分区方案，在mysql5.7中，可以基于范围或事件间隔实现分区方案，有两种选择</p>
<p>1、基于范围的分区，对于分区表达式，可以使用操作函数基于date、time、或者datatime列来返回一个整数值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> members (<br>    firstname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">25</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    lastname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">25</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">35</span>),<br>    joined <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>)<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span>( <span class="hljs-keyword">YEAR</span>(joined) ) (<br>    <span class="hljs-keyword">PARTITION</span> p0 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">1960</span>),<br>    <span class="hljs-keyword">PARTITION</span> p1 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">1970</span>),<br>    <span class="hljs-keyword">PARTITION</span> p2 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">1980</span>),<br>    <span class="hljs-keyword">PARTITION</span> p3 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">1990</span>),<br>    <span class="hljs-keyword">PARTITION</span> p4 <span class="hljs-keyword">VALUES</span> LESS THAN MAXVALUE<br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> quarterly_report_status (<br>    report_id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    report_status <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    report_updated <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span><br>)<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span> ( UNIX_TIMESTAMP(report_updated) ) (<br>    <span class="hljs-keyword">PARTITION</span> p0 <span class="hljs-keyword">VALUES</span> LESS THAN ( UNIX_TIMESTAMP(<span class="hljs-string">&#x27;2008-01-01 00:00:00&#x27;</span>) ),<br>    <span class="hljs-keyword">PARTITION</span> p1 <span class="hljs-keyword">VALUES</span> LESS THAN ( UNIX_TIMESTAMP(<span class="hljs-string">&#x27;2008-04-01 00:00:00&#x27;</span>) ),<br>    <span class="hljs-keyword">PARTITION</span> p2 <span class="hljs-keyword">VALUES</span> LESS THAN ( UNIX_TIMESTAMP(<span class="hljs-string">&#x27;2008-07-01 00:00:00&#x27;</span>) ),<br>    <span class="hljs-keyword">PARTITION</span> p3 <span class="hljs-keyword">VALUES</span> LESS THAN ( UNIX_TIMESTAMP(<span class="hljs-string">&#x27;2008-10-01 00:00:00&#x27;</span>) ),<br>    <span class="hljs-keyword">PARTITION</span> p4 <span class="hljs-keyword">VALUES</span> LESS THAN ( UNIX_TIMESTAMP(<span class="hljs-string">&#x27;2009-01-01 00:00:00&#x27;</span>) ),<br>    <span class="hljs-keyword">PARTITION</span> p5 <span class="hljs-keyword">VALUES</span> LESS THAN ( UNIX_TIMESTAMP(<span class="hljs-string">&#x27;2009-04-01 00:00:00&#x27;</span>) ),<br>    <span class="hljs-keyword">PARTITION</span> p6 <span class="hljs-keyword">VALUES</span> LESS THAN ( UNIX_TIMESTAMP(<span class="hljs-string">&#x27;2009-07-01 00:00:00&#x27;</span>) ),<br>    <span class="hljs-keyword">PARTITION</span> p7 <span class="hljs-keyword">VALUES</span> LESS THAN ( UNIX_TIMESTAMP(<span class="hljs-string">&#x27;2009-10-01 00:00:00&#x27;</span>) ),<br>    <span class="hljs-keyword">PARTITION</span> p8 <span class="hljs-keyword">VALUES</span> LESS THAN ( UNIX_TIMESTAMP(<span class="hljs-string">&#x27;2010-01-01 00:00:00&#x27;</span>) ),<br>    <span class="hljs-keyword">PARTITION</span> p9 <span class="hljs-keyword">VALUES</span> LESS THAN (MAXVALUE)<br>);<br></code></pre></td></tr></table></figure>

<p>2、基于范围列的分区，使用date或者datatime列作为分区列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> members (<br>    firstname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">25</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    lastname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">25</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">35</span>),<br>    joined <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>)<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span> COLUMNS(joined) (<br>    <span class="hljs-keyword">PARTITION</span> p0 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-string">&#x27;1960-01-01&#x27;</span>),<br>    <span class="hljs-keyword">PARTITION</span> p1 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-string">&#x27;1970-01-01&#x27;</span>),<br>    <span class="hljs-keyword">PARTITION</span> p2 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-string">&#x27;1980-01-01&#x27;</span>),<br>    <span class="hljs-keyword">PARTITION</span> p3 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-string">&#x27;1990-01-01&#x27;</span>),<br>    <span class="hljs-keyword">PARTITION</span> p4 <span class="hljs-keyword">VALUES</span> LESS THAN MAXVALUE<br>);<br></code></pre></td></tr></table></figure>

<p>真实案例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs sql">#不分区的表<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> no_part_tab<br>(id <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>remark <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>d_date <span class="hljs-type">DATE</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span><br>)ENGINE<span class="hljs-operator">=</span>MYISAM;<br>#分区的表<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> part_tab<br>(id <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>remark <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>d_date <span class="hljs-type">DATE</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span><br>)ENGINE<span class="hljs-operator">=</span>MYISAM<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span>(<span class="hljs-keyword">YEAR</span>(d_date))(<br><span class="hljs-keyword">PARTITION</span> p0 <span class="hljs-keyword">VALUES</span> LESS THAN(<span class="hljs-number">1995</span>),<br><span class="hljs-keyword">PARTITION</span> p1 <span class="hljs-keyword">VALUES</span> LESS THAN(<span class="hljs-number">1996</span>),<br><span class="hljs-keyword">PARTITION</span> p2 <span class="hljs-keyword">VALUES</span> LESS THAN(<span class="hljs-number">1997</span>),<br><span class="hljs-keyword">PARTITION</span> p3 <span class="hljs-keyword">VALUES</span> LESS THAN(<span class="hljs-number">1998</span>),<br><span class="hljs-keyword">PARTITION</span> p4 <span class="hljs-keyword">VALUES</span> LESS THAN(<span class="hljs-number">1999</span>),<br><span class="hljs-keyword">PARTITION</span> p5 <span class="hljs-keyword">VALUES</span> LESS THAN(<span class="hljs-number">2000</span>),<br><span class="hljs-keyword">PARTITION</span> p6 <span class="hljs-keyword">VALUES</span> LESS THAN(<span class="hljs-number">2001</span>),<br><span class="hljs-keyword">PARTITION</span> p7 <span class="hljs-keyword">VALUES</span> LESS THAN(<span class="hljs-number">2002</span>),<br><span class="hljs-keyword">PARTITION</span> p8 <span class="hljs-keyword">VALUES</span> LESS THAN(<span class="hljs-number">2003</span>),<br><span class="hljs-keyword">PARTITION</span> p9 <span class="hljs-keyword">VALUES</span> LESS THAN(<span class="hljs-number">2004</span>),<br><span class="hljs-keyword">PARTITION</span> p10 <span class="hljs-keyword">VALUES</span> LESS THAN maxvalue);<br>#插入未分区表记录<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span> IF <span class="hljs-keyword">EXISTS</span> no_load_part;<br> <br><br>DELIMITER<span class="hljs-operator">/</span><span class="hljs-operator">/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> no_load_part()<br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">INT</span>;<br>    <span class="hljs-keyword">SET</span> i <span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br>    WHILE i<span class="hljs-operator">&lt;</span><span class="hljs-number">80001</span><br>    DO<br>    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> no_part_tab <span class="hljs-keyword">VALUES</span>(i,<span class="hljs-string">&#x27;no&#x27;</span>,ADDDATE(<span class="hljs-string">&#x27;1995-01-01&#x27;</span>,(RAND(i)<span class="hljs-operator">*</span><span class="hljs-number">36520</span>) MOD <span class="hljs-number">3652</span>));<br>    <span class="hljs-keyword">SET</span> i<span class="hljs-operator">=</span>i<span class="hljs-operator">+</span><span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">END</span> WHILE;<br><span class="hljs-keyword">END</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span><br>DELIMITER ;<br> <br><span class="hljs-keyword">CALL</span> no_load_part;<br>#插入分区表记录<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span> IF <span class="hljs-keyword">EXISTS</span> load_part;<br> <br>DELIMITER<span class="hljs-operator">&amp;&amp;</span> <br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> load_part()<br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">INT</span>;<br>    <span class="hljs-keyword">SET</span> i<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br>    WHILE i<span class="hljs-operator">&lt;</span><span class="hljs-number">80001</span><br>    DO<br>    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> part_tab <span class="hljs-keyword">VALUES</span>(i,<span class="hljs-string">&#x27;partition&#x27;</span>,ADDDATE(<span class="hljs-string">&#x27;1995-01-01&#x27;</span>,(RAND(i)<span class="hljs-operator">*</span><span class="hljs-number">36520</span>) MOD <span class="hljs-number">3652</span>));<br>    <span class="hljs-keyword">SET</span> i<span class="hljs-operator">=</span>i<span class="hljs-operator">+</span><span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">END</span> WHILE;<br><span class="hljs-keyword">END</span><span class="hljs-operator">&amp;&amp;</span><br>DELIMITER ;<br> <br><span class="hljs-keyword">CALL</span> load_part;<br></code></pre></td></tr></table></figure>

<p>列表分区:</p>
<p>类似于按range分区，区别在于list分区是基于列值匹配一个离散值集合中的某个值来进行选择</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> employees (<br> id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br> fname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>),<br> lname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>),<br> hired <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;1970-01-01&#x27;</span>,<br> separated <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;9999-12-31&#x27;</span>,<br> job_code <span class="hljs-type">INT</span>,<br> store_id <span class="hljs-type">INT</span><br>)<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> LIST(store_id) (<br> <span class="hljs-keyword">PARTITION</span> pNorth <span class="hljs-keyword">VALUES</span> <span class="hljs-keyword">IN</span> (<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">17</span>),<br> <span class="hljs-keyword">PARTITION</span> pEast <span class="hljs-keyword">VALUES</span> <span class="hljs-keyword">IN</span> (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">19</span>,<span class="hljs-number">20</span>),<br> <span class="hljs-keyword">PARTITION</span> pWest <span class="hljs-keyword">VALUES</span> <span class="hljs-keyword">IN</span> (<span class="hljs-number">4</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">18</span>),<br> <span class="hljs-keyword">PARTITION</span> pCentral <span class="hljs-keyword">VALUES</span> <span class="hljs-keyword">IN</span> (<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>)<br>);<br></code></pre></td></tr></table></figure>

<p>列分区:</p>
<p>mysql从5.5开始支持column分区，可以认为i是range和list的升级版，在5.5之后，可以使用column分区替代range和list，但是column分区只接受普通列不接受表达式</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `list_c` (<br> `c1` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br> `c2` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span><br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>latin1<br><span class="hljs-comment">/*!50500 PARTITION BY RANGE COLUMNS(c1)</span><br><span class="hljs-comment">(PARTITION p0 VALUES LESS THAN (5) ENGINE = InnoDB,</span><br><span class="hljs-comment"> PARTITION p1 VALUES LESS THAN (10) ENGINE = InnoDB) */</span><br><br> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `list_c` (<br> `c1` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br> `c2` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br> `c3` <span class="hljs-type">char</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span><br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>latin1<br><span class="hljs-comment">/*!50500 PARTITION BY RANGE COLUMNS(c1,c3)</span><br><span class="hljs-comment">(PARTITION p0 VALUES LESS THAN (5,&#x27;aaa&#x27;) ENGINE = InnoDB,</span><br><span class="hljs-comment"> PARTITION p1 VALUES LESS THAN (10,&#x27;bbb&#x27;) ENGINE = InnoDB) */</span><br><br> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `list_c` (<br> `c1` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br> `c2` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br> `c3` <span class="hljs-type">char</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span><br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>latin1<br><span class="hljs-comment">/*!50500 PARTITION BY LIST COLUMNS(c3)</span><br><span class="hljs-comment">(PARTITION p0 VALUES IN (&#x27;aaa&#x27;) ENGINE = InnoDB,</span><br><span class="hljs-comment"> PARTITION p1 VALUES IN (&#x27;bbb&#x27;) ENGINE = InnoDB) */</span><br></code></pre></td></tr></table></figure>

<p>hash分区:</p>
<p>基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含myql中有效的、产生非负整数值的任何表达式</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> employees (<br>    id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    fname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>),<br>    lname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>),<br>    hired <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;1970-01-01&#x27;</span>,<br>    separated <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;9999-12-31&#x27;</span>,<br>    job_code <span class="hljs-type">INT</span>,<br>    store_id <span class="hljs-type">INT</span><br>)<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> HASH(store_id)<br>PARTITIONS <span class="hljs-number">4</span>;<br><br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> employees (<br>    id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    fname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>),<br>    lname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>),<br>    hired <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;1970-01-01&#x27;</span>,<br>    separated <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;9999-12-31&#x27;</span>,<br>    job_code <span class="hljs-type">INT</span>,<br>    store_id <span class="hljs-type">INT</span><br>)<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> LINEAR HASH(<span class="hljs-keyword">YEAR</span>(hired))<br>PARTITIONS <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure>

<p>key分区:</p>
<p>类似于hash分区，区别在于key分区只支持一列或多列，且mysql服务器提供其自身的哈希函数，必须有一列或多列包含整数值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tk (<br>    col1 <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    col2 <span class="hljs-type">CHAR</span>(<span class="hljs-number">5</span>),<br>    col3 <span class="hljs-type">DATE</span><br>)<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> LINEAR KEY (col1)<br>PARTITIONS <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure>

<p>子分区:</p>
<p>在分区的基础之上，再进行分区后存储</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_partition_by_subpart`<br>(<br>  `id` <span class="hljs-type">INT</span> AUTO_INCREMENT,<br>  `sName` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `sAge` <span class="hljs-type">INT</span>(<span class="hljs-number">2</span>) UNSIGNED ZEROFILL <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `sAddr` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `sGrade` <span class="hljs-type">INT</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `sStuId` <span class="hljs-type">INT</span>(<span class="hljs-number">8</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `sSex` <span class="hljs-type">INT</span>(<span class="hljs-number">1</span>) UNSIGNED <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`, `sGrade`)<br>)  ENGINE <span class="hljs-operator">=</span> INNODB<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span>(id)<br>SUBPARTITION <span class="hljs-keyword">BY</span> HASH(sGrade) SUBPARTITIONS <span class="hljs-number">2</span><br>(<br><span class="hljs-keyword">PARTITION</span> p0 <span class="hljs-keyword">VALUES</span> LESS THAN(<span class="hljs-number">5</span>),<br><span class="hljs-keyword">PARTITION</span> p1 <span class="hljs-keyword">VALUES</span> LESS THAN(<span class="hljs-number">10</span>),<br><span class="hljs-keyword">PARTITION</span> p2 <span class="hljs-keyword">VALUES</span> LESS THAN(<span class="hljs-number">15</span>)<br>);<br></code></pre></td></tr></table></figure>

<h2 id="如何使用分区表"><a href="#如何使用分区表" class="headerlink" title="如何使用分区表"></a>如何使用分区表</h2><p>如果需要从非常大的表中查询出某一段时间的记录，而这张表中包含很多年的历史数据，数据是按照时间排序的，此时应该如何查询数据呢？<br>因为数据量巨大，肯定不能在每次查询的时候都扫描全表。考虑到索引在空间和维护上的消耗，也不希望使用索引，即使使用索引，会发现会产生大量的碎片，还会产生大量的随机IO，但是当数据量超大的时候，索引也就无法起作用了，此时可以考虑使用分区来进行解决</p>
<h3 id="全量扫描数据，不要任何索引"><a href="#全量扫描数据，不要任何索引" class="headerlink" title="全量扫描数据，不要任何索引"></a>全量扫描数据，不要任何索引</h3><p>使用简单的分区方式存放表，不要任何索引，根据分区规则大致定位需要的数据为止，通过使用where条件将需要的数据限制在少数分区中，这种策略适用于以正常的方式访问大量数据</p>
<h3 id="索引数据，并分离热点"><a href="#索引数据，并分离热点" class="headerlink" title="索引数据，并分离热点"></a>索引数据，并分离热点</h3><p>如果数据有明显的热点，而且除了这部分数据，其他数据很少被访问到，那么可以将这部分热点数据单独放在一个分区中，让这个分区的数据能够有机会都缓存在内存中，这样查询就可以只访问一个很小的分区表，能够使用索引，也能够有效的使用缓存</p>
<h2 id="在使用分区表的时候需要注意的问题"><a href="#在使用分区表的时候需要注意的问题" class="headerlink" title="在使用分区表的时候需要注意的问题"></a>在使用分区表的时候需要注意的问题</h2><p>null值会使分区过滤无效</p>
<p>分区列和索引列不匹配，会导致查询无法进行分区过滤</p>
<p>选择分区的成本可能很高</p>
<p>打开并锁住所有底层表的成本可能很高</p>
<p>维护分区的成本可能很高</p>
<h1 id="集群化"><a href="#集群化" class="headerlink" title="集群化"></a>集群化</h1><p>主从复制</p>
<p>读写分离</p>
<p>分库分表</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/mysql/">mysql</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/mysql/">mysql</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/05/18/mysql/mysql%E6%9E%B6%E6%9E%84/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">mysql架构</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/05/18/%E6%9D%83%E9%99%90%E6%A1%86%E6%9E%B6/shiro%E5%AE%9E%E8%B7%B5/">
                        <span class="hidden-mobile">shiro实践</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        京ICP备18028493号
      </a>
    </span>
    
      
        <span>
          <a
            href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010502035713"
            rel="nofollow noopener"
            class="beian-police"
            target="_blank"
          >
            
              <span style="visibility: hidden; width: 0">|</span>
              <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
            
            <span>11010502035713</span>
          </a>
        </span>
      
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
