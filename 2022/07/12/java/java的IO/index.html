

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="韩启川">
  <meta name="keywords" content="">
  
    <meta name="description" content="linux文件系统linux中常说的一句话  “ 一切皆文件” 数据块： 硬盘分成相同大小的单元，我们称为块（Block）。一块的大小是扇区大小的整数倍，默认是 4K。 Inode: index  node,  linux中文件抽象出来的一个数据结构(class), index就是索引，就是去哪找组成文件的数据块。 文件描述符 fd（File Descriptor）: 当使用系统调用 open 打">
<meta property="og:type" content="article">
<meta property="og:title" content="java的IO">
<meta property="og:url" content="http://hanqichuan.com/2022/07/12/java/java%E7%9A%84IO/index.html">
<meta property="og:site_name" content="这是一个很酷的事">
<meta property="og:description" content="linux文件系统linux中常说的一句话  “ 一切皆文件” 数据块： 硬盘分成相同大小的单元，我们称为块（Block）。一块的大小是扇区大小的整数倍，默认是 4K。 Inode: index  node,  linux中文件抽象出来的一个数据结构(class), index就是索引，就是去哪找组成文件的数据块。 文件描述符 fd（File Descriptor）: 当使用系统调用 open 打">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hanqichuan.com/.com//linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.webp">
<meta property="og:image" content="http://hanqichuan.com/.com//DMA%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F.webp">
<meta property="og:image" content="http://hanqichuan.com/.com//%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%92%E5%BA%A6%E7%9A%84IO.png">
<meta property="og:image" content="http://hanqichuan.com/.com//%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%80%E6%AC%A1IO%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="http://hanqichuan.com/.com//%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B.png">
<meta property="og:image" content="http://hanqichuan.com/.com//%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B.png">
<meta property="og:image" content="http://hanqichuan.com/.com//IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8Bselect.png">
<meta property="og:image" content="http://hanqichuan.com/.com//IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8Bselect.png">
<meta property="og:image" content="http://hanqichuan.com/.com//IO%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.png">
<meta property="article:published_time" content="2022-07-12T05:46:00.000Z">
<meta property="article:modified_time" content="2022-07-18T04:43:30.637Z">
<meta property="article:author" content="韩启川">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://hanqichuan.com/.com//linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.webp">
  
  
  <title>java的IO - 这是一个很酷的事</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"hanqichuan.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>这是一件很酷的事</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="java的IO">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-07-12 13:46" pubdate>
        2022年7月12日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      22k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      188 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">java的IO</h1>
            
            <div class="markdown-body">
              <h1 id="linux文件系统"><a href="#linux文件系统" class="headerlink" title="linux文件系统"></a>linux文件系统</h1><p>linux中常说的一句话  “ 一切皆文件”</p>
<p>数据块：</p>
<p>硬盘分成相同大小的单元，我们称为块（Block）。一块的大小是扇区大小的整数倍，默认是 4K。</p>
<p>Inode:</p>
<p>index  node,  linux中文件抽象出来的一个数据结构(class), index就是索引，就是去哪找组成文件的数据块。</p>
<p>文件描述符 fd（File Descriptor）:</p>
<p>当使用系统调用 open 打开一个文件时，操作系统会创建一些数据结构来表示这个被打开的文件。为了能够找到这些数据结构，在进程中，我们会为这个打开的文件分配一个文件描述符 fd（File Descriptor）。</p>
<p>pageCache：</p>
<p>内存比磁盘快，linux把热点数据放入内存中，这个块区域称为pageCache。</p>
<p>虚拟文件系统VFS:</p>
<p>Linux 可以支持多达数十种不同的文件系统（ext4、ext3、ntfs）。它们的实现各不相同，因此 Linux 内核向用户空间提供了虚拟文件系统这个统一的接口，来对文件系统进行操作。</p>
<p><img src="/.com//linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.webp" srcset="/img/loading.gif" lazyload alt="linux文件系统"></p>
<h1 id="DMA-Direct-Memory-Access，直接存储器访问"><a href="#DMA-Direct-Memory-Access，直接存储器访问" class="headerlink" title="DMA(Direct Memory Access，直接存储器访问)"></a>DMA(Direct Memory Access，直接存储器访问)</h1><p>是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于CPU的大量中断负载。否则，CPU 需要从来源把每一片段的资料复制到寄存器，然后把它们再次写回到新的地方。在这个时间中，CPU 对于其他的工作来说就无法使用。</p>
<p><img src="/.com//DMA%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F.webp" srcset="/img/loading.gif" lazyload alt="DMA传输方式"></p>
<p>1）用户进程向 CPU 发起 read 系统调用读取数据，由用户态切换为内核态，然后一直阻塞等待数据的返回。</p>
<p>2）CPU 在接收到指令以后对 DMA 磁盘控制器发起调度指令。</p>
<p>3）DMA 磁盘控制器对磁盘发起 I&#x2F;O 请求，将磁盘数据先放入磁盘控制器缓冲区，CPU 全程不参与此过程。</p>
<p>4）数据读取完成后，DMA 磁盘控制器会接受到磁盘的通知，将数据从磁盘控制器缓冲区拷贝到内核缓冲区。</p>
<p>5）DMA 磁盘控制器向 CPU 发出数据读完的信号，由 CPU 负责将数据从内核缓冲区拷贝到用户缓冲区。</p>
<p>6）用户进程由内核态切换回用户态，解除阻塞状态，然后等待 CPU 的下一个执行时间钟。</p>
<h1 id="内核缓冲区与进程缓冲区"><a href="#内核缓冲区与进程缓冲区" class="headerlink" title="内核缓冲区与进程缓冲区"></a>内核缓冲区与进程缓冲区</h1><p>缓冲区的目的，是为了减少频繁的系统IO调用。大家都知道，系统调用需要保存之前的进程数据和状态等信息，而结束调用之后回来还需要恢复之前的信息，为了减少这种损耗时间、也损耗性能的系统调用，于是出现了缓冲区。</p>
<p>有了缓冲区，操作系统使用read函数把数据从内核缓冲区复制到进程缓冲区，write把数据从进程缓冲区复制到内核缓冲区中。等待缓冲区达到一定数量的时候，再进行IO的调用，提升性能。至于什么时候读取和存储则由内核来决定，用户程序不需要关心。</p>
<p>在linux系统中，系统内核也有个缓冲区叫做内核缓冲区。每个进程有自己独立的缓冲区，叫做进程缓冲区。</p>
<p>所以，用户程序的IO读写程序，大多数情况下，并没有进行实际的IO操作，而是在读写自己的进程缓冲区。 </p>
<h1 id="什么是IO"><a href="#什么是IO" class="headerlink" title="什么是IO"></a>什么是IO</h1><p>O，英文全称是Input&#x2F;Output，翻译过来就是<strong>输入&#x2F;输出</strong>。平时我们听得挺多，就是什么磁盘IO，网络IO。那IO到底是什么呢？是不是有种懵懵懂懂的感觉呀，好像大概知道它是什么，又好像说不清楚。</p>
<p><strong>IO，即输入&#x2F;输出</strong>，到底谁是输入？谁是输出呢？IO如果脱离了主体，就会让人疑惑。</p>
<h2 id="计算机角度的IO"><a href="#计算机角度的IO" class="headerlink" title="计算机角度的IO"></a>计算机角度的IO</h2><p>我们常说的输入输出，比较直观的意思就是<strong>计算机的输入输出</strong>，<strong>计算机就是主体</strong>。大家是否还记得，大学学<strong>计算机组成原理</strong>的时候，有个<strong>冯.诺依曼结构</strong>，它将计算机分成分为5个部分：运算器、控制器、存储器、输入设备、输出设备。</p>
<p><img src="/.com//%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%92%E5%BA%A6%E7%9A%84IO.png" srcset="/img/loading.gif" lazyload alt="计算机角度的IO"></p>
<p>输入设备是向计算机输入数据和信息的设备，键盘，鼠标都属于输入设备；输出设备是计算机硬件系统的终端设备，用于接收计算机数据的输出显示，一般显示器、打印机属于输出设备。</p>
<blockquote>
<p> 例如你在鼠标键盘敲几下，它就会把你的指令数据，传给主机，主机通过运算后，把返回的数据信息，输出到显示器。 </p>
</blockquote>
<p>鼠标、显示器这只是直观表面的输入输出，回到计算机架构来说，<strong>涉及计算机核心与其他设备间数据迁移的过程，就是IO</strong>。如磁盘IO，就是从磁盘读取数据到内存，这算一次输入，对应的，将内存中的数据写入磁盘，就算输出。这就是IO的本质。</p>
<h2 id="操作系统的IO"><a href="#操作系统的IO" class="headerlink" title="操作系统的IO"></a>操作系统的IO</h2><p>我们要将内存中的数据写入到磁盘的话，主体会是什么呢？主体可能是一个应用程序，比如一个Java进程（假设网络传来二进制流，一个Java进程可以把它写入到磁盘）。</p>
<p><strong>操作系统</strong>负责计算机的资源管理和进程的调度。我们电脑上跑着的应用程序，其实是需要经过<strong>操作系统</strong>，才能做一些特殊操作，如<strong>磁盘文件读写、内存的读写</strong>等等。因为这些都是比较危险的操作，不可以由应用程序乱来，只能交给底层操作系统来。也就是说，你的应用程序要把数据写入磁盘，只能通过调用操作系统开放出来的API来操作。</p>
<blockquote>
</blockquote>
<blockquote>
<p>  什么是用户空间？什么是内核空间?  </p>
</blockquote>
<blockquote>
<p>  以32位操作系统为例，它为每一个进程都分配了4G(2的32次方)的内存空间。这4G可访问的内存空间分为二部分，一部分是用户空间，一部分是内核空间。内核空间是操作系统内核访问的区域，是受保护的内存空间，而用户空间是用户应用程序访问的内存区域。  </p>
</blockquote>
<blockquote>
</blockquote>
<p>我们应用程序是跑在用户空间的，它不存在实质的IO过程，真正的IO是在<strong>操作系统</strong>执行的。即应用程序的IO操作分为两种动作：<strong>IO调用和IO执行</strong>。IO调用是由进程（应用程序的运行态）发起，而IO执行是<strong>操作系统内核</strong>的工作。此时所说的IO是应用程序对操作系统IO功能的一次触发，即IO调用。</p>
<h1 id="操作系统的一次IO过程"><a href="#操作系统的一次IO过程" class="headerlink" title="操作系统的一次IO过程"></a>操作系统的一次IO过程</h1><p>应用程序发起的一次IO操作包含两个阶段：</p>
<ul>
<li><p>IO调用：应用程序进程向操作系统<strong>内核</strong>发起调用。  </p>
</li>
<li><p>IO执行：操作系统内核完成IO操作。</p>
</li>
</ul>
<p>操作系统内核完成IO操作还包括两个过程：</p>
<ul>
<li><p>准备数据阶段：内核等待I&#x2F;O设备准备好数据  </p>
</li>
<li><p>拷贝数据阶段：将数据从内核缓冲区拷贝到用户进程缓冲区</p>
</li>
</ul>
<p><img src="/.com//%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%80%E6%AC%A1IO%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt="操作系统的一次IO过程"></p>
<p>其实IO就是把进程的内部数据转移到外部设备，或者把外部设备的数据迁移到进程内部。外部设备一般指硬盘、socket通讯的网卡。一个完整的<strong>IO过程</strong>包括以下几个步骤：</p>
<ul>
<li><p>应用程序进程向操作系统发起<strong>IO调用请求</strong></p>
</li>
<li><p>操作系统<strong>准备数据</strong>，把IO外部设备的数据，加载到<strong>内核缓冲区</strong></p>
</li>
<li><p>操作系统拷贝数据，即将内核缓冲区的数据，拷贝到用户进程缓冲区</p>
</li>
</ul>
<h2 id="阻塞和非阻塞的区别"><a href="#阻塞和非阻塞的区别" class="headerlink" title="阻塞和非阻塞的区别"></a>阻塞和非阻塞的区别</h2><p>阻塞和非阻塞的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。</p>
<p>同步和异步的区别是否会导致发起IO请求的线程暂停。</p>
<h2 id="同步与异步的区别"><a href="#同步与异步的区别" class="headerlink" title="同步与异步的区别"></a>同步与异步的区别</h2><p>同步需要通过用户线程或者内核不断地去轮询数据是否就绪。</p>
<p>异步是IO操作的两个阶段都是由内核自动完成，然后发送通知告知用户线程IO操作已经完成。</p>
<h1 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h1><p>我们已经知道IO是什么啦，那什么是<strong>阻塞IO</strong>呢？</p>
<p>假设应用程序的进程发起<strong>IO调用</strong>，但是如果<strong>内核的数据还没准备好</strong>的话，那应用程序进程就一直在<strong>阻塞等待</strong>，一直等到内核数据准备好了，从内核拷贝到用户空间，才返回成功提示，此次IO操作，称之为<strong>阻塞IO</strong>。</p>
<p><img src="/.com//%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B.png" srcset="/img/loading.gif" lazyload alt="阻塞IO模型"></p>
<ul>
<li><p>阻塞IO比较经典的应用就是<strong>阻塞socket、Java BIO</strong>。  </p>
</li>
<li><p>阻塞IO的缺点就是：如果内核数据一直没准备好，那用户进程将一直阻塞，<strong>浪费性能</strong>，可以使用<strong>非阻塞IO</strong>优化。</p>
</li>
</ul>
<h1 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h1><p>如果内核数据还没准备好，可以先返回错误信息给用户进程，让它不需要等待，而是通过轮询的方式再来请求。这就是非阻塞IO，流程图如下：</p>
<p><img src="/.com//%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B.png" srcset="/img/loading.gif" lazyload alt="非阻塞IO模型"></p>
<p>非阻塞IO的流程如下：</p>
<ul>
<li><p>应用进程向操作系统内核，发起<code>recvfrom</code>读取数据。  </p>
</li>
<li><p>操作系统内核数据没有准备好，立即返回<code>EWOULDBLOCK</code>错误码。  </p>
</li>
<li><p>应用程序进程轮询调用，继续向操作系统内核发起<code>recvfrom</code>读取数据。  </p>
</li>
<li><p>操作系统内核数据准备好了，从内核缓冲区拷贝到用户空间。  </p>
</li>
<li><p>完成调用，返回成功提示。</p>
</li>
</ul>
<p>非阻塞IO模型，简称<strong>NIO</strong>，<code>Non-Blocking IO</code>。它相对于阻塞IO，虽然大幅提升了性能，但是它依然存在<strong>性能问题</strong>，即<strong>频繁的轮询</strong>，导致频繁的系统调用，同样会消耗大量的CPU资源。可以考虑<strong>IO复用模型</strong>，去解决这个问题。</p>
<h1 id="IO多路复用模型"><a href="#IO多路复用模型" class="headerlink" title="IO多路复用模型"></a>IO多路复用模型</h1><p>既然<strong>NIO</strong>无效的轮询会导致CPU资源消耗，我们等到内核数据准备好了，主动通知应用进程再去进行系统调用，那不就好了嘛？</p>
<p>当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p>
<p>IO复用模型核心思路：系统给我们提供<strong>一类函数</strong>（如我们耳濡目染的<strong>select、poll、epoll</strong>函数），它们可以同时监控多个<code>fd</code>的操作，任何一个返回内核数据就绪，应用进程再发起<code>recvfrom</code>系统调用。</p>
<h2 id="IO多路复用之select"><a href="#IO多路复用之select" class="headerlink" title="IO多路复用之select"></a>IO多路复用之select</h2><p>应用进程通过调用<strong>select</strong>函数，可以同时监控多个<code>fd</code>，在<code>select</code>函数监控的<code>fd</code>中，只要有任何一个数据状态准备就绪了，<code>select</code>函数就会返回可读状态，这时应用进程再发起<code>recvfrom</code>请求去读取数据。</p>
<p><img src="/.com//IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8Bselect.png" srcset="/img/loading.gif" lazyload alt="IO多路复用之select"></p>
<p>非阻塞IO模型（NIO）中，需要<code>N</code>（N&gt;&#x3D;1）次轮询系统调用，然而借助<code>select</code>的IO多路复用模型，只需要发起一次询问就够了,大大优化了性能。</p>
<p>但是呢，<code>select</code>有几个缺点：</p>
<ul>
<li><p>监听的IO最大连接数有限，在Linux系统上一般为1024。  </p>
</li>
<li><p>select函数返回后，是通过<strong>遍历</strong><code>fdset</code>，找到就绪的描述符<code>fd</code>。（仅知道有I&#x2F;O事件发生，却不知是哪几个流，所以<strong>遍历所有流</strong>）</p>
</li>
</ul>
<p>因为<strong>存在连接数限制</strong>，所以后来又提出了<strong>poll</strong>。与select相比，<strong>poll</strong>解决了<strong>连接数限制问题</strong>。但是呢，select和poll一样，还是需要通过遍历文件描述符来获取已经就绪的<code>socket</code>。如果同时连接的大量客户端，在一时刻可能只有极少处于就绪状态，伴随着监视的描述符数量的增长，<strong>效率也会线性下降</strong>。</p>
<p>因此经典的多路复用模型<code>epoll</code>诞生。</p>
<h1 id="IO多路复用之epoll"><a href="#IO多路复用之epoll" class="headerlink" title="IO多路复用之epoll"></a>IO多路复用之epoll</h1><p>为了解决<code>select/poll</code>存在的问题，多路复用模型<code>epoll</code>诞生，它采用事件驱动来实现，流程图如下：</p>
<p><img src="/.com//IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8Bselect.png" srcset="/img/loading.gif" lazyload alt="IO多路复用之select"></p>
<p><strong>epoll</strong>先通过<code>epoll_ctl()</code>来注册一个<code>fd</code>（文件描述符），一旦基于某个<code>fd</code>就绪时，内核会采用回调机制，迅速激活这个<code>fd</code>，当进程调用<code>epoll_wait()</code>时便得到通知。这里去掉了<strong>遍历文件描述符</strong>的坑爹操作，而是采用<strong>监听事件回调</strong>的机制。这就是epoll的亮点。</p>
<p><strong>我们一起来总结一下select、poll、epoll的区别</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>select</th>
<th>poll</th>
<th>epoll</th>
</tr>
</thead>
<tbody><tr>
<td>底层数据结构</td>
<td>数组</td>
<td>链表</td>
<td>红黑树和双链表</td>
</tr>
<tr>
<td>获取就绪的fd</td>
<td>遍历</td>
<td>遍历</td>
<td>事件回调</td>
</tr>
<tr>
<td>事件复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>最大连接数</td>
<td>1024</td>
<td>无限制</td>
<td>无限制</td>
</tr>
<tr>
<td>fd数据拷贝</td>
<td>每次调用select</td>
<td>需要将fd数据从用户空间拷贝到内核空间 每次调用poll，需要将fd数据从用户空间拷贝到内核空间</td>
<td>使用内存映射(mmap)，不需要从用户空间频繁拷贝fd数据到内核空间</td>
</tr>
</tbody></table>
<p><strong>epoll</strong>明显优化了IO的执行效率，但在进程调用<code>epoll_wait()</code>时，仍然可能被阻塞。能不能酱紫：不用我老是去问你数据是否准备就绪，等我发出请求后，你数据准备好了通知我就行了，这就诞生了<strong>信号驱动IO模型</strong>。</p>
<h1 id="IO模型之信号驱动模型"><a href="#IO模型之信号驱动模型" class="headerlink" title="IO模型之信号驱动模型"></a>IO模型之信号驱动模型</h1><p>信号驱动IO不再用主动询问的方式去确认数据是否就绪，而是向内核发送一个信号（调用<code>sigaction</code>的时候建立一个<code>SIGIO</code>的信号），然后应用用户进程可以去做别的事，不用阻塞。当内核数据准备好后，再通过<code>SIGIO</code>信号通知应用进程，数据准备好后的可读状态。应用用户进程收到信号之后，立即调用<code>recvfrom</code>，去读取数据。</p>
<p><img src="/.com//IO%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.png" srcset="/img/loading.gif" lazyload alt="IO模型之信号驱动模型"></p>
<p>信号驱动IO模型，在应用进程发出信号后，是立即返回的，不会阻塞进程。它已经有异步操作的感觉了。但是你细看上面的流程图，<strong>发现数据复制到应用缓冲的时候</strong>，应用进程还是阻塞的。回过头来看下，不管是BIO，还是NIO，还是信号驱动，在数据从内核复制到应用缓冲的时候，都是阻塞的。还有没有优化方案呢？<strong>AIO</strong>（真正的异步IO）！</p>
<h1 id="IO-模型之异步IO-AIO"><a href="#IO-模型之异步IO-AIO" class="headerlink" title="IO 模型之异步IO(AIO)"></a>IO 模型之异步IO(AIO)</h1><p>前面讲的<code>BIO，NIO和信号驱动</code>，在数据从内核复制到应用缓冲的时候，都是<strong>阻塞</strong>的，因此都不算是真正的异步。<code>AIO</code>实现了IO全流程的非阻塞，就是应用进程发出系统调用后，是立即返回的，但是<strong>立即返回的不是处理结果，而是表示提交成功类似的意思</strong>。等内核数据准备好，将数据拷贝到用户进程缓冲区，发送信号通知用户进程IO操作执行完毕。</p>
<p>流程如下：</p>
<p>![IO 模型之异步IO(AIO)](img&#x2F;IO 模型之异步IO(AIO).png)</p>
<p>异步IO的优化思路很简单，只需要向内核发送一次请求，就可以完成数据状态询问和数据拷贝的所有操作，并且不用阻塞等待结果。日常开发中，有类似思想的业务场景：</p>
<blockquote>
</blockquote>
<blockquote>
<p>比如发起一笔批量转账，但是批量转账处理比较耗时，这时候后端可以先告知前端转账提交成功，等到结果处理完，再通知前端结果即可。</p>
</blockquote>
<blockquote>
</blockquote>
<h1 id="阻塞、非阻塞、同步、异步IO总结"><a href="#阻塞、非阻塞、同步、异步IO总结" class="headerlink" title="阻塞、非阻塞、同步、异步IO总结"></a>阻塞、非阻塞、同步、异步IO总结</h1><ul>
<li><p>同步阻塞(blocking-IO)简称BIO  </p>
</li>
<li><p>同步非阻塞(non-blocking-IO)简称NIO  </p>
</li>
<li><p>异步非阻塞(asynchronous-non-blocking-IO)简称AIO</p>
</li>
</ul>
<p>BIO：同步阻塞，在服务器中实现的模式为<strong>一个连接一个线程</strong>。也就是说，客户端有连接请求的时候，服务器就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然这也可以通过线程池机制改善。BIO<strong>一般适用于连接数目小且固定的架构</strong>，这种方式对于服务器资源要求比较高，而且并发局限于应用中，是JDK1.4之前的唯一选择，但好在程序直观简单，易理解。</p>
<p>NIO：同步非阻塞，在服务器中实现的模式为<strong>一个请求一个线程</strong>，也就是说，客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到有连接IO请求时才会启动一个线程进行处理。<strong>NIO一般适用于连接数目多且连接比较短（轻操作）的架构</strong>，并发局限于应用中，编程比较复杂，从JDK1.4开始支持。</p>
<p>AIO：异步并非阻塞，在服务器中实现的模式为<strong>一个有效请求一个线程</strong>，也就是说，客户端的IO请求都是通过操作系统先完成之后，再通知服务器应用去启动线程进行处理。AIO一般适用于连接数目多且连接比较长（重操作）的架构，充分调用操作系统参与并发操作，编程比较复杂，从JDK1.7开始支持。</p>
<h1 id="编写java-IO代码及查看系统调用"><a href="#编写java-IO代码及查看系统调用" class="headerlink" title="编写java IO代码及查看系统调用"></a>编写java IO代码及查看系统调用</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43970890/article/details/118355800">https://blog.csdn.net/weixin_43970890/article/details/118355800</a></p>
<h2 id="查看系统调用的工具"><a href="#查看系统调用的工具" class="headerlink" title="查看系统调用的工具"></a>查看系统调用的工具</h2><p>strace -ff -o .&#x2F;out java Test.java</p>
<h2 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h2><h2 id="网络IO"><a href="#网络IO" class="headerlink" title="网络IO"></a>网络IO</h2><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BIOSocket</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8090</span>);<br>        System.out.println(<span class="hljs-string">&quot;step1: new ServerSocket &quot;</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>            System.out.println(<span class="hljs-string">&quot;step2: client\t&quot;</span> + client.getPort());<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> client.getInputStream();<br>                    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(in));<br>                    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                        System.out.println(reader.readLine());<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SocketClient</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;xxx&quot;</span>,<span class="hljs-number">8090</span>);<br><br>            client.setSendBufferSize(<span class="hljs-number">20</span>);<br>            client.setTcpNoDelay(<span class="hljs-literal">true</span>);<br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> client.getOutputStream();<br><br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> System.in;<br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(in));<br><br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> reader.readLine();<br>                <span class="hljs-keyword">if</span>(line != <span class="hljs-literal">null</span> )&#123;<br>                    <span class="hljs-type">byte</span>[] bb = line.getBytes();<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">byte</span> b : bb) &#123;<br>                        out.write(b);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>启动时</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 5<br>bind(5, &#123;sa_family=AF_INET, sin_port=htons(8090), sin_addr=inet_addr(&quot;0.0.0.0&quot;)&#125;, 16) = 0<br>listen(5, 50)                           = 0<br>poll([&#123;fd=5, events=POLLIN|POLLERR&#125;], 1, -1) = 1 ([&#123;fd=5, revents=POLLIN&#125;])<br></code></pre></td></tr></table></figure>

<p>poll函数会阻塞直到其中任何一个fd发生事件。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">accept(5, &#123;sa_family=AF_INET, sin_port=htons(10253), sin_addr=inet_addr(&quot;42.120.74.252&quot;)&#125;, [16]) = 6<br>clone(child_stack=0x7f013e5c4fb0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0x7f013e5c59d0,         tls=0x7f013e5c5700, child_tidptr=0x7f013e5c59d0) = 13168<br>poll([&#123;fd=5, events=POLLIN|POLLERR&#125;], 1, -1<br></code></pre></td></tr></table></figure>

<p>抛出线程（即我们代码里的 new Thread() ）后，继续poll阻塞等待连接。</p>
<p><strong>clone出来的线程</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">recvfrom(6, &quot;hello,bio\n&quot;, 8192, 0, NULL, NULL) =<br></code></pre></td></tr></table></figure>

<p>关于对recvfrom函数的说明，其中第四个参数0 表示这是一个阻塞调用。</p>
<p><strong>客户端发送数据后</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">recvfrom(6, &quot;hello,bio\n&quot;, 8192, 0, NULL, NULL) = 10<br></code></pre></td></tr></table></figure>

<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOSocket</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> LinkedList&lt; SocketChannel&gt; clients = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startClientChannelHandleThread</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(<span class="hljs-number">4096</span>);<br> <br>                <span class="hljs-comment">//处理客户端连接</span><br>                <span class="hljs-keyword">for</span> (SocketChannel c : clients) &#123;<br>                    <span class="hljs-comment">// 非阻塞, &gt;0 表示读取到的字节数量, 0或-1表示未读取到或读取异常</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        num = c.read(buffer);<br>                    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br> <br>                    <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>                        buffer.flip();<br>                        <span class="hljs-type">byte</span>[] clientBytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[buffer.limit()];<br>                        <span class="hljs-comment">//从缓冲区 读取到内存中</span><br>                        buffer.get(clientBytes);<br> <br>                        System.out.println(c.socket().getPort() + <span class="hljs-string">&quot;:&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(clientBytes));<br> <br>                        <span class="hljs-comment">//清空缓冲区</span><br>                        buffer.clear();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//new socket,开启监听</span><br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>        socketChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">9090</span>));<br>        <span class="hljs-comment">//设置阻塞接受客户端连接</span><br>        socketChannel.configureBlocking(<span class="hljs-literal">true</span>);<br> <br>        <span class="hljs-comment">//开始client处理线程</span><br>        startClientChannelHandleThread();<br> <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">//接受客户端连接; 非阻塞，无客户端返回null(操作系统返回-1)</span><br>            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> socketChannel.accept();<br> <br>            <span class="hljs-keyword">if</span> (client == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//System.out.println(&quot;no client&quot;);</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//设置读非阻塞</span><br>                client.configureBlocking(<span class="hljs-literal">false</span>);<br> <br>                <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> client.socket().getPort();<br>                System.out.println(<span class="hljs-string">&quot;client port :&quot;</span> + port);<br> <br>                clients.add(client);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>主线程</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 4<br>bind(4, &#123;sa_family=AF_INET, sin_port=htons(9090), sin_addr=inet_addr(&quot;0.0.0.0&quot;)&#125;, 16) = 0<br>listen(4, 50)                           = 0<br>fcntl(4, F_SETFL, O_RDWR|O_NONBLOCK)    = 0<br>accept(4, 0x7fe26414e680, 0x7fe26c376710) = -1 EAGAIN (Resource temporarily unavailable)<br></code></pre></td></tr></table></figure>

<p><strong>有连接后，子线程</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">read(6, 0x7f3f415b1c50, 4096)           = -1 EAGAIN (Resource temporarily unavailable)<br>read(6, 0x7f3f415b1c50, 4096)           = -1 EAGAIN (Resource temporarily unavailable)<br>...<br></code></pre></td></tr></table></figure>

<h3 id="多路复用器（select、poll、epoll）"><a href="#多路复用器（select、poll、epoll）" class="headerlink" title="多路复用器（select、poll、epoll）"></a>多路复用器（select、poll、epoll）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiplexingSocket</span> &#123;<br> <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(<span class="hljs-number">4096</span>);<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br> <br>        LinkedList&lt; SocketChannel&gt; clients = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br> <br>        <span class="hljs-comment">//1.启动server</span><br>        <span class="hljs-comment">//new socket,开启监听</span><br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>        socketChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">9090</span>));<br>        <span class="hljs-comment">//设置非阻塞，接受客户端</span><br>        socketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br> <br>        <span class="hljs-comment">//多路复用器（JDK包装的代理，select /poll/epoll/kqueue）</span><br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open(); <span class="hljs-comment">//java自动代理，默认为epoll</span><br>        <span class="hljs-comment">//Selector selector = PollSelectorProvider.provider().openSelector();//指定为poll</span><br> <br>        <span class="hljs-comment">//将服务端socket 注册到 多路复用器</span><br>        socketChannel.register(selector, SelectionKey.OP_ACCEPT);<br> <br>        <span class="hljs-comment">//2. 轮训多路复用器</span><br>        <span class="hljs-comment">// 先询问有没有连接,如果有则返回数量以及对应的对象(fd)</span><br>        <span class="hljs-keyword">while</span> (selector.select() &gt; <span class="hljs-number">0</span>) &#123;<br>            System.out.println();<br>            Set&lt; SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>            Iterator&lt; SelectionKey&gt; iter = selectionKeys.iterator();<br> <br>            <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                iter.remove();<br> <br>                <span class="hljs-comment">//2.1 处理新的连接</span><br>                <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                    <span class="hljs-comment">//接受客户端连接; 非阻塞，无客户端返回null(操作系统返回-1)</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> socketChannel.accept();<br>                    <span class="hljs-comment">//设置读非阻塞</span><br>                    client.configureBlocking(<span class="hljs-literal">false</span>);<br> <br>                    <span class="hljs-comment">//同样，把client也注册到selector</span><br>                    client.register(selector, SelectionKey.OP_READ);<br>                    System.out.println(<span class="hljs-string">&quot;new client : &quot;</span> + client.getRemoteAddress());<br>                &#125;<br>                <span class="hljs-comment">//2.2 处理读取数据</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                    readDataFromSocket(key);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readDataFromSocket</span><span class="hljs-params">(SelectionKey key)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>        <span class="hljs-comment">// 非阻塞, &gt;0 表示读取到的字节数量, 0或-1表示未读取到或读取异常</span><br>        <span class="hljs-comment">// 请注意：这个例子降低复杂度，不考虑报文大于buffer size的情况</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> socketChannel.read(buffer);<br> <br>        <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>            buffer.flip();<br>            <span class="hljs-type">byte</span>[] clientBytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[buffer.limit()];<br>            <span class="hljs-comment">//从缓冲区 读取到内存中</span><br>            buffer.get(clientBytes);<br> <br>            System.out.println(socketChannel.socket().getPort() + <span class="hljs-string">&quot;:&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(clientBytes));<br> <br>            <span class="hljs-comment">//清空缓冲区</span><br>            buffer.clear();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>启动</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 4<br>bind(4, &#123;sa_family=AF_INET, sin_port=htons(9090), sin_addr=inet_addr(&quot;0.0.0.0&quot;)&#125;, 16) = 0<br>listen(4, 50)<br>fcntl(4, F_SETFL, O_RDWR|O_NONBLOCK)    = 0<br>epoll_create(256)                       = 7<br>epoll_ctl(7, EPOLL_CTL_ADD, 5, &#123;EPOLLIN, &#123;u32=5, u64=4324783852322029573&#125;&#125;) = 0<br>epoll_ctl(7, EPOLL_CTL_ADD, 4, &#123;EPOLLIN, &#123;u32=4, u64=158913789956&#125;&#125;) = 0<br>epoll_wait(7<br></code></pre></td></tr></table></figure>

<p>关于对epoll_create（对应着Java的 Selector selector &#x3D; Selector.open()） 的说明，本质上是在内存的操作系统保留区，创建一个epoll数据结构。用于后面当有client连接时，向该epoll区中添加监听。</p>
<p><strong>有连接</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">epoll_wait(7,[&#123;EPOLLIN, &#123;u32=4, u64=158913789956&#125;&#125;], 8192, -1) = 1<br>accept(4, &#123;sa_family=AF_INET, sin_port=htons(29597), sin_addr=inet_addr(&quot;42.120.74.252&quot;)&#125;, [16]) = 8<br>fcntl(8, F_SETFL, O_RDWR|O_NONBLOCK)    = 0<br>epoll_ctl(7, EPOLL_CTL_ADD, 8, &#123;EPOLLIN, &#123;u32=8, u64=3212844375897800712&#125;&#125;) = 0<br></code></pre></td></tr></table></figure>

<p>关于epoll_ctl （对应着Java的 client.register(selector, SelectionKey.OP_READ) ）。其中 EPOLLIN 恰好对应着Java的 SelectionKey.OP_READ 即监听数据到达读取事件。</p>
<p><strong>客户端发送数据</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">epoll_wait(7,[&#123;EPOLLIN, &#123;u32=8, u64=3212844375897800712&#125;&#125;], 8192, -1) = 1<br>read(8, &quot;hello,multiplex\n&quot;, 4096)      = 16<br>epoll_wait(7,<br></code></pre></td></tr></table></figure>

<p>epoll_wait第四个参数-1表示block。</p>
<h3 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TelnetServer</span> &#123;<br> <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">SSL</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;ssl&quot;</span>) != <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PORT</span> <span class="hljs-operator">=</span> Integer.parseInt(System.getProperty(<span class="hljs-string">&quot;port&quot;</span>, SSL? <span class="hljs-string">&quot;8992&quot;</span> : <span class="hljs-string">&quot;8023&quot;</span>));<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// Configure SSL.</span><br>        <span class="hljs-keyword">final</span> SslContext sslCtx;<br>        <span class="hljs-keyword">if</span> (SSL) &#123;<br>            <span class="hljs-type">SelfSignedCertificate</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelfSignedCertificate</span>();<br>            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sslCtx = <span class="hljs-literal">null</span>;<br>        &#125;<br> <br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>            b.group(bossGroup, workerGroup)<br>             .channel(NioServerSocketChannel.class)<br>             .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.INFO))<br>             .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TelnetServerInitializer</span>(sslCtx));<br> <br>            b.bind(PORT).sync().channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Sharable</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TelnetServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt; String&gt; &#123;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// Send greeting for a new connection.</span><br>        ctx.write(<span class="hljs-string">&quot;Welcome to &quot;</span> + InetAddress.getLocalHost().getHostName() + <span class="hljs-string">&quot;!\r\n&quot;</span>);<br>        ctx.write(<span class="hljs-string">&quot;It is &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot; now.\r\n&quot;</span>);<br>        ctx.flush();<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, String request)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// Generate and write a response.</span><br>        String response;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">close</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (request.isEmpty()) &#123;<br>            response = <span class="hljs-string">&quot;Please type something.\r\n&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;bye&quot;</span>.equals(request.toLowerCase())) &#123;<br>            response = <span class="hljs-string">&quot;Have a good day!\r\n&quot;</span>;<br>            close = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            response = <span class="hljs-string">&quot;Did you say &#x27;&quot;</span> + request + <span class="hljs-string">&quot;&#x27;?\r\n&quot;</span>;<br>        &#125;<br> <br>        <span class="hljs-comment">// We do not need to write a ChannelBuffer here.</span><br>        <span class="hljs-comment">// We know the encoder inserted at TelnetPipelineFactory will do the conversion.</span><br>        <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">future</span> <span class="hljs-operator">=</span> ctx.write(response);<br> <br>        <span class="hljs-comment">// Close the connection after sending &#x27;Have a good day!&#x27;</span><br>        <span class="hljs-comment">// if the client has sent &#x27;bye&#x27;.</span><br>        <span class="hljs-keyword">if</span> (close) &#123;<br>            future.addListener(ChannelFutureListener.CLOSE);<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>        ctx.flush();<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TelnetServerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInitializer</span>&lt; SocketChannel&gt; &#123;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StringDecoder</span> <span class="hljs-variable">DECODER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDecoder</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StringEncoder</span> <span class="hljs-variable">ENCODER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEncoder</span>();<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">TelnetServerHandler</span> <span class="hljs-variable">SERVER_HANDLER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TelnetServerHandler</span>();<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SslContext sslCtx;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TelnetServerInitializer</span><span class="hljs-params">(SslContext sslCtx)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sslCtx = sslCtx;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br> <br>        <span class="hljs-keyword">if</span> (sslCtx != <span class="hljs-literal">null</span>) &#123;<br>            pipeline.addLast(sslCtx.newHandler(ch.alloc()));<br>        &#125;<br> <br>        <span class="hljs-comment">// Add the text line codec combination first,</span><br>        pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DelimiterBasedFrameDecoder</span>(<span class="hljs-number">8192</span>, Delimiters.lineDelimiter()));<br>        <span class="hljs-comment">// the encoder and decoder are static as these are sharable</span><br>        pipeline.addLast(DECODER);<br>        pipeline.addLast(ENCODER);<br> <br>        <span class="hljs-comment">// and then business logic.</span><br>        pipeline.addLast(SERVER_HANDLER);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>主线程(23109)</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs text">## 256无实际作用，这里只为了兼容旧版kernel api<br>epoll_create(256)                       = 7epoll_ctl(7, EPOLL_CTL_ADD, 5, &#123;EPOLLIN, &#123;u32=5, u64=5477705356928876549&#125;&#125;) = 0<br> <br>epoll_create(256)                       = 10epoll_ctl(10, EPOLL_CTL_ADD, 8, &#123;EPOLLIN, &#123;u32=8, u64=17041805914081853448&#125;&#125;) = 0<br> <br>epoll_create(256)                       = 13<br>epoll_ctl(13, EPOLL_CTL_ADD, 11, &#123;EPOLLIN, &#123;u32=11, u64=17042151607409573899&#125;&#125;) = 0<br> <br>epoll_create(256)                       = 16<br>epoll_ctl(16, EPOLL_CTL_ADD, 14, &#123;EPOLLIN, &#123;u32=14, u64=17042497300737294350&#125;&#125;) = 0<br> <br>epoll_create(256)                       = 19<br>epoll_ctl(19, EPOLL_CTL_ADD, 17, &#123;EPOLLIN, &#123;u32=17, u64=17042561450368827409&#125;&#125;) = 0<br> <br>epoll_create(256)                       = 10<br>socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 20<br>clone(child_stack=0x7fc3c509afb0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0x7fc3c509b9d0, tls=0x7fc3c509b700, child_tidptr=0x7fc3c509b9d0) = 23130<br></code></pre></td></tr></table></figure>

<p>概括为：</p>
<p>向OS新建socket，并开启clone boss线程23130。<br>为BOSS创建了一个epoll（论证参见下面“boss”），每个worker创建一个epoll数据结构（本质上是在kernel内存区创建了一个数据结构，用于后续监听）。<br>创建boss线程监听的socket（本质上在kernel中创建一个数据结构）。</p>
<p><strong>boss（23130）</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">bind(20, &#123;sa_family=AF_INET, sin_port=htons(8023), sin_addr=inet_addr(&quot;0.0.0.0&quot;)&#125;, 16) = 0<br>listen(20, 128)                         = 0<br>getsockname(20, &#123;sa_family=AF_INET, sin_port=htons(8023), sin_addr=inet_addr(&quot;0.0.0.0&quot;)&#125;, [16]) = 0<br>getsockname(20, &#123;sa_family=AF_INET, sin_port=htons(8023), sin_addr=inet_addr(&quot;0.0.0.0&quot;)&#125;, [16]) = 0 <br> <br>##将fd为7号epoll和fd为20号的socket绑定，事件：epoll_ctl_add和epoll_ctl_mod<br>epoll_ctl(7, EPOLL_CTL_ADD, 20, &#123;EPOLLIN, &#123;u32=20, u64=14198059139132817428&#125;&#125;) = 0<br>epoll_ctl(7, EPOLL_CTL_MOD, 20, &#123;EPOLLIN, &#123;u32=20, u64=20&#125;&#125;) = 0<br>epoll_wait(7, [&#123;EPOLLIN, &#123;u32=5, u64=17295150779149058053&#125;&#125;], 8192, 1000) = 1<br>epoll_wait(7, [], 8192, 1000)           = 0(不断轮训，1S超时一次)<br></code></pre></td></tr></table></figure>

<p>概括为：</p>
<p>将上一步中main线程创建的fd：20绑定端口8023，并开启监听（网卡负责监听和接受连接和数据，kernel则负责路由到具体进程，具体参见：关于socket和bind和listen，TODO ）。<br>将7号socket对应的fd绑定到20号对应的epoll数据结构上去（都是操作kernel中的内存）。<br>开始1S中一次阻塞等待epoll有任何连接或数据到达。</p>
<p><strong>客户端连接</strong></p>
<p><strong>boss (23130)</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">accept(20, &#123;sa_family=AF_INET, sin_port=htons(11144), sin_addr=inet_addr(&quot;42.120.74.122&quot;)&#125;, [16]) = 24<br>getsockname(24, &#123;sa_family=AF_INET, sin_port=htons(8023), sin_addr=inet_addr(&quot;192.168.0.120&quot;)&#125;, [16]) = 0<br>getsockname(24, &#123;sa_family=AF_INET, sin_port=htons(8023), sin_addr=inet_addr(&quot;192.168.0.120&quot;)&#125;, [16]) = 0<br>setsockopt(24, SOL_TCP, TCP_NODELAY, [1], 4) = 0<br>getsockopt(24, SOL_SOCKET, SO_SNDBUF, [87040], [4]) = 0<br>getsockopt(24, SOL_SOCKET, SO_SNDBUF, [87040], [4]) = 0<br>##抛出 work线程<br>clone(child_stack=0x7fc3c4c98fb0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0x7fc3c4c999d0, tls=0x7fc3c4c99700, child_tidptr=0x7fc3c4c999d0) = 2301<br></code></pre></td></tr></table></figure>

<p><strong>worker (2301)</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">writev(24, [&#123;&quot;Welcome to iZbp14e1g9ztpshfrla9m&quot;..., 37&#125;, &#123;&quot;It is Sun Aug 23 15:44:14 CST 20&quot;..., 41&#125;], 2) = 78<br>epoll_ctl(13, EPOLL_CTL_ADD, 24, &#123;EPOLLIN, &#123;u32=24, u64=24&#125;&#125;) = 0<br>epoll_ctl(13, EPOLL_CTL_MOD, 24, &#123;EPOLLIN, &#123;u32=24, u64=14180008216221450264&#125;&#125;) = 0<br>epoll_wait(13, [&#123;EPOLLIN, &#123;u32=11, u64=17042151607409573899&#125;&#125;], 8192, 1000) = 1 <br>read(11, &quot;\1&quot;, 128)                     = 1<br>##开始无限loop<br>epoll_wait(13, [], 8192, 1000)          = 0<br>epoll_wait(13, [&#123;EPOLLIN, &#123;u32=24, u64=24&#125;&#125;], 8192, 1000) = 1<br></code></pre></td></tr></table></figure>

<p>概括：</p>
<p>当BOSS轮训epoll_wait等到了连接后，首先accept得到该socket对应的fd。<br>连接建立后 BOSS立马抛出一个线程（clone函数）。<br>worker（即新建的线程）写入了一段数据（这里是业务逻辑）。<br>worker将该client对应的fd绑定到了13号epoll上。<br>worker继续轮训监听13号epoll。</p>
<p><strong>客户端主动发送数据</strong></p>
<p><strong>worker（2301）</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">read(24, &quot;i am daojian\r\n&quot;, 1024)      = 14<br>write(24, &quot;Did you say &#x27;i am daojian&#x27;?\r\n&quot;, 29) = 29<br>##继续无限loop<br>epoll_wait(13, [], 8192, 1000)          = 0<br></code></pre></td></tr></table></figure>

<p>概括为：</p>
<ul>
<li>wait到数据后，立即read到用户控件内存中（读取1024个字节到 用户控件某个buff中）。</li>
<li>写入数据（业务逻辑，不必太关注）。</li>
<li>继续轮训等待13号epoll。</li>
</ul>
<p><strong>客户端发送bye报文，服务器断开TCP连接</strong></p>
<p><strong>worker（2301）</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">read(24, &quot;bye\r\n&quot;, 1024)               = 5<br>write(24, &quot;Have a good day!\r\n&quot;, 18)   = 18<br>getsockopt(24, SOL_SOCKET, SO_LINGER, &#123;onoff=0, linger=0&#125;, [8]) = 0<br>dup2(25, 24)                            = 24<br>##从epoll数据结构中（OS）中删除fd为24的socket<br>epoll_ctl(13, EPOLL_CTL_DEL, 24, 0x7f702dd531e0) = -1 ENOENT<br>##关闭24 socket<br>close(24)                               = 0<br>##继续等待13 epoll数据<br>epoll_wait(13, [], 8192, 1000)          = 0<br></code></pre></td></tr></table></figure>

<p>断开客户端连接概括为：</p>
<ul>
<li>从epoll中删除该客户端对应的fd（这里触发源头没找到，可能是boss）。</li>
<li>close关闭客户端24号fd。</li>
<li>继续轮训epoll。</li>
</ul>
<p><strong>五个客户端同时连接</strong></p>
<p><strong>boss线程（23130）</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">accept(20, &#123;sa_family=AF_INET, sin_port=htons(1846), sin_addr=inet_addr(&quot;42.120.74.122&quot;)&#125;, [16]) = 24<br>clone(child_stack=0x7f702cc51fb0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0x7f702cc529d0, tls=0x7f702cc52700, child_tidptr=0x7f702cc529d0) = 10035<br> <br>accept(20, &#123;sa_family=AF_INET, sin_port=htons(42067), sin_addr=inet_addr(&quot;42.120.74.122&quot;)&#125;, [16]) = 26<br>clone(child_stack=0x7f702cb50fb0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0x7f702cb519d0, tls=0x7f702cb51700, child_tidptr=0x7f702cb519d0) = 10067<br> <br>...<br></code></pre></td></tr></table></figure>

<p><strong>woker线程（10035，第一个连接）</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">epoll_ctl(13, EPOLL_CTL_ADD, 24, &#123;EPOLLIN, &#123;u32=24, u64=24&#125;&#125;) = 0<br>epoll_ctl(13, EPOLL_CTL_MOD, 24, &#123;EPOLLIN, &#123;u32=24, u64=3226004877247250456&#125;&#125;) = 0<br>epoll_wait(13, [&#123;EPOLLIN, &#123;u32=11, u64=17042151607409573899&#125;&#125;], 8192, 1000) = 1                  = 1<br>epoll_wait(13, [], 8192, 1000)          = 0<br></code></pre></td></tr></table></figure>

<p><strong>worker线程（10067，第二个连接）</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">epoll_ctl(16, EPOLL_CTL_ADD, 26, &#123;EPOLLIN, &#123;u32=26, u64=26&#125;&#125;) = 0<br>epoll_ctl(16, EPOLL_CTL_MOD, 26, &#123;EPOLLIN, &#123;u32=26, u64=3221483685433835546&#125;&#125;) = 0<br>epoll_wait(16, [&#123;EPOLLIN, &#123;u32=14, u64=17042497300737294350&#125;&#125;], 8192, 1000) = 1<br>epoll_wait(16, [], 8192, 1000)          = 0<br>epoll_wait(16, [], 8192, 1000)          = 0<br></code></pre></td></tr></table></figure>

<p><strong>worker线程（10067，第二个连接）</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">epoll_ctl(19, EPOLL_CTL_ADD, 27, &#123;EPOLLIN, &#123;u32=27, u64=27&#125;&#125;) = 0<br>epoll_ctl(19, EPOLL_CTL_MOD, 27, &#123;EPOLLIN, &#123;u32=27, u64=3216966479350071323&#125;&#125;) = 0<br></code></pre></td></tr></table></figure>

<p><strong>worker线程(8055，第四个连接)</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">epoll_ctl(10, EPOLL_CTL_ADD, 28, &#123;EPOLLIN, &#123;u32=28, u64=28&#125;&#125;) = 0<br>epoll_ctl(10, EPOLL_CTL_MOD, 28, &#123;EPOLLIN, &#123;u32=28, u64=3302604828697427996&#125;&#125;) = 0<br></code></pre></td></tr></table></figure>

<p><strong>worker线程（10035，第五个连接，不在clone线程，而是复用了第一个epoll对应的worker）</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">epoll_ctl(13, EPOLL_CTL_ADD, 29, &#123;EPOLLIN, &#123;u32=29, u64=29&#125;&#125;) = 0<br>epoll_ctl(13, EPOLL_CTL_MOD, 29, &#123;EPOLLIN, &#123;u32=29, u64=29&#125;&#125;) = 0<br></code></pre></td></tr></table></figure>

<p>概括为：</p>
<ul>
<li>epoll和boss、worker之间的关系：一共有4个worker对应着4个epoll对象，boss和每个worker都有对应自己的epoll。</li>
<li>boss根据epoll数量，平衡分配连接到每个worker对应的epoll中。</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/java/">java</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/java/">java</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/08/08/%E6%96%B9%E6%B3%95%E8%AE%BA/%E4%BD%BF%E7%94%A8PLAN%E6%B3%95%E6%8F%90%E5%8D%87%E6%89%A7%E8%A1%8C%E5%8A%9B/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">使用PLAN法提升执行力</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/07/11/java/java%E9%9B%86%E5%90%88/">
                        <span class="hidden-mobile">java集合</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        京ICP备18028493号
      </a>
    </span>
    
      
        <span>
          <a
            href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010502035713"
            rel="nofollow noopener"
            class="beian-police"
            target="_blank"
          >
            
              <span style="visibility: hidden; width: 0">|</span>
              <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
            
            <span>11010502035713</span>
          </a>
        </span>
      
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
