

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="韩启川">
  <meta name="keywords" content="">
  
    <meta name="description" content="并发编程目的：让程序充分利用计算机资源加快程序响应速度（耗时任务、web服务器）简化异步事件的处理 什么时候适合使用并发编程任务会阻塞线程，导致之后的代码不能执行：比如一边从文件中读取，一边进行大量计算的情况任务执行时间过长，可以划分为分工明确的子任务：比如分段下载任务间断性执行：日志打印任务本身需要协作执行：比如生产者消费者问题 串行、并发和并行的区别你吃饭吃到一半，电话来了，你一直到吃完了以后">
<meta property="og:type" content="article">
<meta property="og:title" content="java并发编程">
<meta property="og:url" content="http://hanqichuan.com/2022/07/11/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="这是一个很酷的事">
<meta property="og:description" content="并发编程目的：让程序充分利用计算机资源加快程序响应速度（耗时任务、web服务器）简化异步事件的处理 什么时候适合使用并发编程任务会阻塞线程，导致之后的代码不能执行：比如一边从文件中读取，一边进行大量计算的情况任务执行时间过长，可以划分为分工明确的子任务：比如分段下载任务间断性执行：日志打印任务本身需要协作执行：比如生产者消费者问题 串行、并发和并行的区别你吃饭吃到一半，电话来了，你一直到吃完了以后">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hanqichuan.com/.com//%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.jpg">
<meta property="og:image" content="http://hanqichuan.com/.com//%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%93%E6%9E%84%E5%9B%BE.png">
<meta property="og:image" content="http://hanqichuan.com/.com//%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%B5%81%E7%A8%8B%E5%9B%BE.png">
<meta property="og:image" content="http://hanqichuan.com/.com//synchronized%E5%AE%9E%E7%8E%B0.png">
<meta property="og:image" content="http://hanqichuan.com/.com//AQS%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://hanqichuan.com/.com//CAS%E6%8C%87%E4%BB%A4.png">
<meta property="article:published_time" content="2022-07-11T03:22:00.000Z">
<meta property="article:modified_time" content="2022-07-18T02:41:10.105Z">
<meta property="article:author" content="韩启川">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://hanqichuan.com/.com//%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.jpg">
  
  
  <title>java并发编程 - 这是一个很酷的事</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"hanqichuan.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>这是一件很酷的事</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="java并发编程">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-07-11 11:22" pubdate>
        2022年7月11日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      29k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      242 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">java并发编程</h1>
            
            <div class="markdown-body">
              <h1 id="并发编程目的："><a href="#并发编程目的：" class="headerlink" title="并发编程目的："></a>并发编程目的：</h1><p>让程序充分利用计算机资源<br>加快程序响应速度（耗时任务、web服务器）<br>简化异步事件的处理</p>
<h2 id="什么时候适合使用并发编程"><a href="#什么时候适合使用并发编程" class="headerlink" title="什么时候适合使用并发编程"></a>什么时候适合使用并发编程</h2><p>任务会阻塞线程，导致之后的代码不能执行：比如一边从文件中读取，一边进行大量计算的情况<br>任务执行时间过长，可以划分为分工明确的子任务：比如分段下载<br>任务间断性执行：日志打印<br>任务本身需要协作执行：比如生产者消费者问题</p>
<h1 id="串行、并发和并行的区别"><a href="#串行、并发和并行的区别" class="headerlink" title="串行、并发和并行的区别"></a>串行、并发和并行的区别</h1><p>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。<br>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。<br>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</p>
<p>串行就是第一种。</p>
<p>并发的关键是你有处理多个任务的能力，不一定要同时。<br>并行的关键是你有同时处理多个任务的能力。</p>
<p>所以我认为它们最关键的点就是：是否是『同时』。</p>
<p>如果任务可拆分成并发、并行，可以缩短整个流程的时间。</p>
<h1 id="并发编程带来的问题"><a href="#并发编程带来的问题" class="headerlink" title="并发编程带来的问题"></a>并发编程带来的问题</h1><h2 id="频繁的上下文切换的问题："><a href="#频繁的上下文切换的问题：" class="headerlink" title="频繁的上下文切换的问题："></a>频繁的上下文切换的问题：</h2><p>cpu为线程分配时间片，时间片非常短（毫秒级别），cpu不停的切换线程执行，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态，让我们感觉是多个程序同时运行的。上下文的频繁切换，会带来一定的性能开销<br>如何减少上下文切换？</p>
<p>1.无锁并发编程<br>无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据<br>2.CAS<br>Java的Atomic包使用CAS算法来更新数据，而不需要加锁。<br>3.使用最少线程。<br>避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。<br>4.协程<br>在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</p>
<h2 id="并发编程死锁问题："><a href="#并发编程死锁问题：" class="headerlink" title="并发编程死锁问题："></a>并发编程死锁问题：</h2><p>是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。 </p>
<p>例如：有一个线程A，按照先锁a再获得锁b的的顺序获得锁，而在此同时又有另外一个线程B，按照先锁b再锁a的顺序获得锁。</p>
<p>如何解决死锁：</p>
<p>1、以确定的顺序获得锁</p>
<p>2、超时放弃</p>
<p>3、死锁检测</p>
<p>java中死锁检测工具：</p>
<p>jstack、jconsole、visual VM</p>
<h2 id="并发编程资源限制问题"><a href="#并发编程资源限制问题" class="headerlink" title="并发编程资源限制问题"></a>并发编程资源限制问题</h2><p>硬件资源<br>  服务器： 1m<br>  本机：2m<br>  带宽的上传&#x2F;下载速度、硬盘读写速度和CPU的处理速度。</p>
<p>软件资源<br>  数据库连接 500个连接 1000个线程查询 并不会因此而加快<br>  socket</p>
<h1 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h1><p>进程：是系统进行分配和管理资源的基本单位<br>线程：进程的一个执行单元，是进程内调度的实体、是CPU调度和分派的基本单位，是比进程更小的独立运行的基本单位。线程也被称为轻量级进程,线程是程序执行的最小单位。<br>一个程序至少一个进程，一个进程至少一个线程。<br>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。<br>而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。<br>线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式进行。<br>如何处理好同步与互斥是编写多线程程序的难点。<br>多进程程序更健壮，进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，<br>而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，所以可能一个线程出现问题，进而导致整个程序出现问题</p>
<h1 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h1><p>thread、runable、callable和futureTask配合、线程池</p>
<p>Callable与Runable功能相似，Callable的call有返回值，可以返回给客户端，而Runable没有返回值，一般情况下，Callable与FutureTask一起使用，或者通过线程池的submit方法返回相应的Future</p>
<p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果、设置结果操作。get方法会阻塞，直到任务返回结果。</p>
<p>FutureTask则是一个RunnableFuture，而RunnableFuture实现了Runnbale又实现了Futrue这两个接口</p>
<h1 id="线程的状态及其相互转换"><a href="#线程的状态及其相互转换" class="headerlink" title="线程的状态及其相互转换"></a>线程的状态及其相互转换</h1><p>查看源码Thread类中的内部枚举类state</p>
<p>新建(NEW)：新创建了一个线程对象，但还没有调用start()方法。<br>就绪状态(RUNNABLE):   处于可运行状态的线程正在JVM中执行，但它可能正在等待来自操作系统的其他资源，例如处理器。<br>阻塞(BLOCKED)：线程阻塞于synchronized锁，等待获取synchronized锁的状态。也有可能是自旋锁。<br>等待(WAITING)：Object.wait()、join()、 LockSupport.park(),进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。<br>超时等待(TIME_WAITING)：Thread.sleep()、Object.wait(long)、Thread.join()、LockSupport.parkNanos()、LockSupport.parkUntil，该状态不同于WAITING，它可以在指定的时间内自行返回。<br>终止(TERMINATED)：表示该线程已经执行完毕。</p>
<p><img src="/.com//%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.jpg" srcset="/img/loading.gif" lazyload alt="线程状态"></p>
<p>图中的阻塞包括 BLOCKED、WAITING、TIME_WAITING。</p>
<p>一般不占用CPU。</p>
<h2 id="终止线程的-4种方式"><a href="#终止线程的-4种方式" class="headerlink" title="终止线程的 4种方式"></a>终止线程的 4种方式</h2><p><strong>正常运行结束</strong></p>
<p>程序运行结束，线程自动结束。 </p>
<p><strong>使用退出标志退出线程</strong></p>
<p>一般 run()方法执行完，线程就会正常结束，然而，常常有些线程是伺服线程。它们需要长时间的</p>
<p>运行，只有在外部某些条件满足的情况下，才能关闭这些线程。使用一个变量来控制循环，例如：</p>
<p>最直接的方法就是设一个 boolean 类型的标志，并通过设置这个标志为 true 或 false 来控制 while循环是否退出，代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafe</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">exit</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span> (!exit)&#123;<br>    	<span class="hljs-comment">//do something</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义了一个退出标志 exit，当 exit 为 true 时，while 循环退出，exit 的默认值为 false.在定义 exit时，使用了一个 Java 关键字 volatile，这个关键字的目的是使 exit 同步，也就是说在同一时刻只能由一个线程来修改 exit 的值。</p>
<p><strong>Interrupt</strong> <strong>方法结束线程</strong></p>
<p>使用 interrupt()方法来中断线程有两种情况：</p>
<ol>
<li><p>线程处于阻塞状态：如使用了 sleep,同步锁的 wait,socket 中的 receiver,accept 等方法时，会使线程处于阻塞状态。当调用线程的 interrupt()方法时，会抛出 InterruptException 异常。阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后 break 跳出循环状态，从而让我们有机会结束这个线程的执行。通常很多人认为只要调用 interrupt 方法线程就会结束，实际上是错的， 一定要先捕获 InterruptedException 异常之后通过 break 来跳出循环，才能正常结束 run 方法。</p>
</li>
<li><p>线程未处于阻塞状态：使用 isInterrupted()判断线程的中断标志来退出循环。当使用interrupt()方法时，中断标志就会置 true，和使用自定义的标志来控制循环是一样的道理。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafe</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span> (!isInterrupted())&#123; <span class="hljs-comment">//非阻塞过程中通过判断中断标志来退出</span><br>      <span class="hljs-keyword">try</span>&#123;<br>      	Thread.sleep(<span class="hljs-number">5</span>*<span class="hljs-number">1000</span>);<span class="hljs-comment">//阻塞过程捕获中断异常来退出</span><br>      &#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>      	e.printStackTrace();<br>      	<span class="hljs-keyword">break</span>;<span class="hljs-comment">//捕获到异常之后，执行 break 跳出循环</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>stop</strong> <strong>方法终止线程（线程不安全）</strong></p>
<p>程序中可以直接使用 thread.stop()来强行终止线程，但是 stop 方法是很危险的，就象突然关闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，不安全主要是：thread.stop()调用之后，创建子线程的线程就会抛出 ThreadDeatherror 的错误，并且会释放子线程所持有的所有锁。一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在调用thread.stop()后导致了该线程所持有的所有锁的突然释放(不可控制)，那么被保护数据就有可能呈现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因此，并不推荐使用 stop 方法来终止线程。</p>
<h1 id="线程的常见方法："><a href="#线程的常见方法：" class="headerlink" title="线程的常见方法："></a>线程的常见方法：</h1><p>Sleep(), 意思就是睡眠，当前线程暂停一段时间让给别的线程去运行。由你的睡眠时间而定，等睡眠到规定的时间自动变为运行状态。</p>
<p>Yield(), 就是当前线程正在执行的时候停止下来进入等待队列（就绪状态，CPU依然有可能把这个线程拿出来运行），回到等待队列里在系统的调度算法里还是依然有可能把你刚回去的这个线程拿回来继续执行，当然，更大的可能性是把原来等待的那些拿出一个来执行，所以yield的意思是我让出一下CPU，后面你们能不能抢到那我不管。</p>
<p>join()， 意思就是在自己当前线程加入你调用Join的线程，本线程等待。等调用的线程运行完了，自己再去执行。t1和t2两个线程，在t1的某个点上调用了t2.join,它会跑到t2去运行，t1等待t2运行完毕继续t1运行（自己join自己没有意义）。</p>
<p>Thread.interrupt方法自行定义一个标志，用来判断是否继续执行  interrupt()不能打断正在竞争锁的线程synchronized()。</p>
<p>t.isInterrupted() 查询打断标志位是否被设置（是不是曾经被打断过）。</p>
<p>Thread.interrupted() 查看“当前”线程是否被打断，如果被打断，恢复标志位。</p>
<p>使用ReentrantLock加锁的线程，可以使用ReentrantLock的lockInterruptibly()打断。</p>
<p>在多线程环境下，有时候一个线程的执行，依赖于另外一个线程的某种状态的改变，这个时候，我们就可以使用wait与notify或者notifyAll。</p>
<h2 id="notify跟notifyAll的区别："><a href="#notify跟notifyAll的区别：" class="headerlink" title="notify跟notifyAll的区别："></a>notify跟notifyAll的区别：</h2><p>nofity随机唤醒一个等待的线程<br>notifyAll唤醒所有在该对象上等待的线程</p>
<h2 id="sleep与wait的区别"><a href="#sleep与wait的区别" class="headerlink" title="sleep与wait的区别"></a>sleep与wait的区别</h2><ol>
<li>对于 sleep()方法，我们首先要知道该方法是属于 Thread 类中的。而 wait()方法，则是属于 Object 类中的。</li>
<li>sleep()方法导致了程序暂停执行指定的时间，让出 cpu 给其他线程，但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。 </li>
<li>在调用 sleep()方法的过程中，线程不会释放对象锁。</li>
<li>而当调用 wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用 notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。</li>
<li>wait notify必须放在同步代码块中, 且必须拥有当前对象的锁，即不能取得A对象的锁，而调用B对象的wait，哪个对象wait，就得调哪个对象的notify</li>
</ol>
<h2 id="start与run的区别"><a href="#start与run的区别" class="headerlink" title="start与run的区别"></a>start与run的区别</h2><ol>
<li><p>start()方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码。</p>
</li>
<li><p>通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。</p>
</li>
<li><p>方法 run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行 run 函数当中的代码。 Run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。</p>
</li>
</ol>
<h1 id="线程分类"><a href="#线程分类" class="headerlink" title="线程分类"></a>线程分类</h1><p>用户线程、守护线程<br>守护线程：任何一个守护线程都是整个程序中所有用户线程的守护者，只要有活着的用户线程，守护线程就活着。当JVM实例中最后一个非守护线程结束时，也随JVM一起退出。<br>守护线程的用处：jvm垃圾清理线程<br>建议： 尽量少使用守护线程，因其不可控，不要在守护线程里去进行读写操作、执行计算逻辑</p>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>什么是线程安全性？<br>当多个线程访问某个类,不管运行时环境采用何种调度方式或者这些线程如何交替执行,并且在主调代码中不需要任何额外的同步或协同,这个类都能表现出正确的行为,那么就称这个类为线程安全的。—-《并发编程实战》</p>
<p>什么是线程不安全？<br>多线程并发访问时，得不到正确的结果。例如num++ 非原子操作</p>
<h2 id="如何避免线程安全性问题"><a href="#如何避免线程安全性问题" class="headerlink" title="如何避免线程安全性问题"></a>如何避免线程安全性问题</h2><p>线程安全性问题成因<br>1：多线程环境<br>2：多个线程操作同一共享资源<br>3：对该共享资源进行了非原子性操作</p>
<p>如何避免<br>(打破成因中三点任意一点)<br>1：多线程环境–将多线程改单线程（必要的代码，加锁访问）<br>2：多个线程操作同一共享资源–不共享资源（ThreadLocal、不共享、操作无状态化、不可变）<br>3：对该共享资源进行了非原子性操作– 将非原子性操作改成原子性操作（加锁、使用JDK自带的原子性操作的类、JUC提供的相应的并发工具类）</p>
<h1 id="多线程debug"><a href="#多线程debug" class="headerlink" title="多线程debug"></a>多线程debug</h1><p>idea-&gt;断点-&gt;右健-&gt;suspend-&gt;thread</p>
<h1 id="Java中用到的线程调度"><a href="#Java中用到的线程调度" class="headerlink" title="Java中用到的线程调度"></a>Java中用到的线程调度</h1><h2 id="抢占式调度："><a href="#抢占式调度：" class="headerlink" title="抢占式调度："></a>抢占式调度：</h2><p>抢占式调度指的是每条线程执行的时间、线程的切换都由系统控制，系统控制指的是在系统某种运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片。在这种机制下，一个线程的堵塞不会导致整个进程堵塞。</p>
<h2 id="协同式调度："><a href="#协同式调度：" class="headerlink" title="协同式调度："></a>协同式调度：</h2><p>协同式调度指某一线程执行完后主动通知系统切换到另一线程上执行，这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。线程的执行时间由线程本身控制，线程切换可以预知，不存在多线程同步问题，但它有一个致命弱点：如果一个线程编写有问题，运行到一半就一直堵塞，那么可能导致整个系统崩溃。</p>
<h2 id="JVM-的线程调度实现（抢占式调度）"><a href="#JVM-的线程调度实现（抢占式调度）" class="headerlink" title="JVM 的线程调度实现（抢占式调度）"></a>JVM 的线程调度实现（抢占式调度）</h2><p>java 使用的线程调使用抢占式调度，Java 中线程会按优先级分配 CPU 时间片运行，且优先级越高越优先执行，但优先级高并不代表能独自占用执行时间片，可能是优先级高得到越多的执行时间片，反之，优先级低的分到的执行时间少但不会分配不到执行时间。</p>
<p><strong>线程让出 cpu 的情况：</strong> </p>
<ol>
<li>当前运行线程主动放弃 CPU，JVM 暂时放弃 CPU 操作（基于时间片轮转调度的 JVM 操作系统不会让线程永久放弃 CPU，或者说放弃本次时间片的执行权），例如调用 yield()方法。 </li>
<li>当前运行线程因为某些原因进入阻塞状态，例如阻塞在 I&#x2F;O 上。 </li>
<li>当前运行线程结束，即运行完 run()方法里面的任务。</li>
</ol>
<h1 id="ThreadLocalMap（线程的一个属性）"><a href="#ThreadLocalMap（线程的一个属性）" class="headerlink" title="ThreadLocalMap（线程的一个属性）"></a>ThreadLocalMap（线程的一个属性）</h1><ol>
<li><p>每个线程中都有一个自己的 ThreadLocalMap 类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。 </p>
</li>
<li><p>将一个共用的 ThreadLocal 静态实例作为 key，将不同对象的引用保存到不同线程的ThreadLocalMap 中，然后在线程执行的各处通过这个静态 ThreadLocal 实例的 get()方法取得自己线程保存的那个对象，避免了将这个对象作为参数传递的麻烦。 </p>
</li>
<li><p>ThreadLocalMap 其实就是线程里面的一个属性，它在 Thread 类中定义</p>
</li>
</ol>
<p>ThreadLocal.ThreadLocalMap threadLocals &#x3D; null; </p>
<p>最常见的 ThreadLocal 使用场景为 用来解决 数据库连接、Session 管理等。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ThreadLocal</span> <span class="hljs-variable">threadSession</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>();  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Session <span class="hljs-title function_">getSession</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InfrastructureException &#123;      <br>  <span class="hljs-type">Session</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (Session) threadSession.get();     <br>  <span class="hljs-keyword">try</span> &#123;        <br>      <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>) &#123;          <br>        s = getSessionFactory().openSession();               <br>        threadSession.set(s);   <br>      &#125;   <br>    &#125; <span class="hljs-keyword">catch</span> (HibernateException ex) &#123;     <br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InfrastructureException</span>(ex);   <br>    &#125;   <br>    <span class="hljs-keyword">return</span> s;   <br>&#125; <br></code></pre></td></tr></table></figure>

<h1 id="线程池及Executor框架"><a href="#线程池及Executor框架" class="headerlink" title="线程池及Executor框架"></a>线程池及Executor框架</h1><h2 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a>为什么要使用线程池？</h2><p>每当一个请求到达就创建一个新线程，然后在新线程中为请求服务，但是频繁的创建线程，销毁线程所带来的系统开销其实是非常大的。</p>
<h2 id="线程池参数说明"><a href="#线程池参数说明" class="headerlink" title="线程池参数说明"></a>线程池参数说明</h2><p>corePoolSize：核心线程池大小 cSize<br>maximumPoolSize：线程池最大容量 mSize<br>keepAliveTime：当线程数量大于核心时，多余的空闲线程在终止之前等待新任务的最大时间。<br>unit：时间单位<br>workQueue:工作队列 nWorks<br>ThreadFactory：线程工厂<br>handler：拒绝策略</p>
<p>默认线程池拒绝策略及自定义拒绝策略：<br>AbortPolicy：该策略直接抛出异常，阻止系统正常工作<br>CallerRunsPolicy：只要线程池没有关闭，该策略直接在调用者线程中，执行当前被丢弃的任务（叫老板帮你干活）<br>DiscardPolicy：直接啥事都不干，直接把任务丢弃<br>DiscardOldestPolicy：丢弃最老的一个请求（任务队列里面的第一个），再尝试提交任务</p>
<p>通过new创建线程池时，除非调用prestartAllCoreThreads方法初始化核心线程，否则此时线程池中有0个线程，即使工作队列中存在多个任务，同样不会执行</p>
<h2 id="会启动多少线程执行任务"><a href="#会启动多少线程执行任务" class="headerlink" title="会启动多少线程执行任务"></a>会启动多少线程执行任务</h2><p>任务数X<br>x &lt;&#x3D; cSize —》只启动x个线程<br>x &gt;&#x3D; cSize &amp;&amp; x &lt; nWorks + cSize—》 会启动 &lt;&#x3D; cSize 个线程 其他的任务就放到工作队列里<br>x &gt; cSize &amp;&amp; x &gt; nWorks + cSize–》<br>    x-(nWorks) &lt;&#x3D; mSize 会启动x-(nWorks)个线程<br>    x-(nWorks) &gt; mSize 会启动mSize个线程来执行任务，其余的执行相应的拒绝策略</p>
<h2 id="线程池的组成结构："><a href="#线程池的组成结构：" class="headerlink" title="线程池的组成结构："></a>线程池的组成结构：</h2><p>一个线程池包括四个基本部分<br>1.线程管理池（ThreadPool)：用于创建并管理线程池，有创建，销毁，添加新任务；<br>2.工作线程（PoolWorker）：线程池中的线程在没有任务的时候处于等待状态，可以循环的执行任务；<br>3.任务接口（Task）：每个任务必须实现接口，用来提供工作线程调度任务的执行，规定了任务的入口以及执行结束的收尾工作和任务的执行状态等；<br>4.任务队列：用于存放没有处理的任务，提供一种缓存机制。</p>
<p><img src="/.com//%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%93%E6%9E%84%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="线程池结构图"></p>
<p><img src="/.com//%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%B5%81%E7%A8%8B%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="线程池流程图"></p>
<h2 id="线程池运行的任务异常后，没日志"><a href="#线程池运行的任务异常后，没日志" class="headerlink" title="线程池运行的任务异常后，没日志"></a>线程池运行的任务异常后，没日志</h2><p>线程池未提供打印日志的功能。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">1.修改runable方法，加入try catch<br>2. 自定义线程池，继承ThreadPoolExecutor并复写其afterExecute(Runnable r, Throwable t)方法。 <br>3. 实现Thread.UncaughtExceptionHandler接口，实现void uncaughtException(Thread t, Throwable e);方法，并将该handler传递给线程池的ThreadFactory <br>4. 采用Future模式，将返回结果以及异常放到Future中，在Future中处理 <br>5. 继承ThreadGroup，覆盖其uncaughtException方法。（与第二种方式类似，因为ThreadGroup类本身就实现了Thread.UncaughtExceptionHandler接口)<br></code></pre></td></tr></table></figure>

<h2 id="java提供的几种默认线程池"><a href="#java提供的几种默认线程池" class="headerlink" title="java提供的几种默认线程池"></a>java提供的几种默认线程池</h2><p> Java 里面线程池的顶级接口是 Executors，但是严格意义上讲 Executor 并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是 ExecutorService。 使用Executors创建线程池很简单，但是便捷不仅隐藏了复杂性，也为我们埋下了潜在的隐患（OOM，线程耗尽）。</p>
<p>newFixedThreadPool：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">使用的构造方式为new ThreadPoolExecutor(var0, var0, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue())，设置了corePoolSize=maxPoolSize，keepAliveTime=0(此时该参数没作用)，无界队列，任务可以无限放入，当请求过多时(任务处理速度跟不上任务提交速度造成请求堆积)可能导致占用过多内存或直接导致OOM异常<br></code></pre></td></tr></table></figure>


<p>newSingleThreadExector：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">使用的构造方式为new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue(), var0)，基本同newFixedThreadPool，但是将线程数设置为了1，单线程，弊端和newFixedThreadPool一致<br></code></pre></td></tr></table></figure>


<p>newCachedThreadPool：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">使用的构造方式为new ThreadPoolExecutor(0, 2147483647, 60L, TimeUnit.SECONDS, new SynchronousQueue())，corePoolSize=0，maxPoolSize为很大的数，同步移交队列，也就是说不维护常驻线程(核心线程)，每次来请求直接创建新线程来处理任务，也不使用队列缓冲，会自动回收多余线程，由于将maxPoolSize设置成Integer.MAX_VALUE，当请求很多时就可能创建过多的线程，导致资源耗尽OOM<br></code></pre></td></tr></table></figure>


<p>newScheduledThreadPool：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">使用的构造方式为new ThreadPoolExecutor(var1, 2147483647, 0L, TimeUnit.NANOSECONDS, new ScheduledThreadPoolExecutor.DelayedWorkQueue())，支持定时周期性执行，注意一下使用的是延迟队列，弊端同newCachedThreadPool一致<br></code></pre></td></tr></table></figure>
<h2 id="线程复用与源码解析"><a href="#线程复用与源码解析" class="headerlink" title="线程复用与源码解析"></a>线程复用与源码解析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Proceed in 3 steps:</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="hljs-comment">     * start a new thread with the given command as its first</span><br><span class="hljs-comment">     * task.  The call to addWorker atomically checks runState and</span><br><span class="hljs-comment">     * workerCount, and so prevents false alarms that would add</span><br><span class="hljs-comment">     * threads when it shouldn&#x27;t, by returning false.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. If a task can be successfully queued, then we still need</span><br><span class="hljs-comment">     * to double-check whether we should have added a thread</span><br><span class="hljs-comment">     * (because existing ones died since last checking) or that</span><br><span class="hljs-comment">     * the pool shut down since entry into this method. So we</span><br><span class="hljs-comment">     * recheck state and if necessary roll back the enqueuing if</span><br><span class="hljs-comment">     * stopped, or start a new thread if there are none.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 3. If we cannot queue task, then we try to add a new</span><br><span class="hljs-comment">     * thread.  If it fails, we know we are shut down or saturated</span><br><span class="hljs-comment">     * and so reject the task.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br>            <span class="hljs-keyword">return</span>;<br>        c = ctl.get();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>        reject(command);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>1.线程池里执行的是任务,核心逻辑在ThreadPoolExecutor类的execute方法中,同时ThreadPoolExecutor中维护了HashSet<Worker> workers;<br>2.addWorker()方法来创建线程执行任务,如果是核心线程的任务,会赋值给Worker的firstTask属性;<br>3.Worker实现了Runnable,本质上也是任务,核心在run()方法里;<br>4.run()方法的执行核心runWorker(),自旋拿任务while (task !&#x3D; null || (task &#x3D; getTask()) !&#x3D; null)),task是核心线程Worker的firstTask或者getTask();<br>5.getTask()的核心逻辑:<br>        1.若当前工作线程数量大于核心线程数-&gt;说明此线程是非核心工作线程,通过poll()拿任务,未拿到任务即getTask()返回null,然后会在processWorkerExit(w, completedAbruptly)方法释放掉这个非核心工作线程的引用;<br>        2.若当前工作线程数量小于核心线程数-&gt;说明此时线程是核心工作线程,通过take()拿任务<br>        3.take()方式取任务,如果队列中没有任务了会调用await()阻塞当前线程,直到新任务到来,所以核心工作线程不会被回收; 当执行execute方法里的workQueue.offer(command)时会调用Condition.singal()方法唤醒一个之前阻塞的线程,这样核心线程即可复用</Worker></p>
<h2 id="execute与submit的区别"><a href="#execute与submit的区别" class="headerlink" title="execute与submit的区别"></a>execute与submit的区别</h2><ol>
<li>execute是Executor接口的方法，而submit是ExecutorService的方法，并且ExecutorService接口继承了Executor接口。</li>
<li>execute只接受Runnable参数，没有返回值；而submit可以接受Runnable参数和Callable参数，并且返回了Future对象，可以进行任务取消、获取任务结果、判断任务是否执行完毕&#x2F;取消等操作。其中，submit会对Runnable或Callable入参封装成RunnableFuture对象，调用execute方法并返回。</li>
<li>通过execute方法提交的任务如果出现异常则直接抛出原异常，是在线程池中的线程中；而submit方法是捕获了异常的，只有当调用Future的get方法时，才会抛出ExecutionException异常，且是在调用get方法的线程。</li>
</ol>
<h1 id="JAVA锁"><a href="#JAVA锁" class="headerlink" title="JAVA锁"></a>JAVA锁</h1><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。 </p>
<p>java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。 </p>
<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。 java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如 RetreenLock。 </p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。 </p>
<p>线程自旋是需要消耗 cup 的，说白了就是让 cup 在做无用功，如果一直获取不到锁，那线程也不能一直占用 cup 自旋做无用功，所以需要设定一个自旋等待的最大时间。</p>
<p>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p>
<p>自旋锁的优缺点 </p>
<p>自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！</p>
<p>但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cup 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁； </p>
<p>自旋锁时间阈值（1.6引入了适应性自旋锁） </p>
<p>自旋锁的目的是为了占着 CPU 的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！ </p>
<p>JVM 对于自旋周期的选择，jdk1.5 这个限度是一定的写死的，在 1.6 引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时 JVM 还针对当前 CPU 的负荷情况做了较多的优化，如果平均负载小于 CPUs 则一直自旋，如果有超过(CPUs&#x2F;2) 个线程正在自旋，则后来线程直接阻塞，如果正在自旋的线程发现 Owner 发生了变化则延迟自旋时间（自旋计数）或进入阻塞，如果 CPU 处于节电模式则停止自旋，自旋时间的最坏情况是 CPU 的存储延迟（CPU A 存储了一个数据，到 CPU B 得知这个数据直接的时间差），自旋时会适当放弃线程优先级之间的差异。 </p>
<p>自旋锁的开启 </p>
<p>JDK1.6 中-XX:+UseSpinning 开启； </p>
<p>-XX:PreBlockSpin&#x3D;10 为自旋次数； </p>
<p>JDK1.7 后，去掉此参数，由 jvm 控制； </p>
<h2 id="可重入锁（递归锁）"><a href="#可重入锁（递归锁）" class="headerlink" title="可重入锁（递归锁）"></a>可重入锁（递归锁）</h2><p>这里面讲的是广义上的可重入锁，而不是单指JAVA 下的ReentrantLock。可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。在 JAVA 环境下 ReentrantLock 和 synchronized 都是 可重入锁。 </p>
<h2 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h2><p>公平锁（Fair） </p>
<p>加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得 </p>
<p>非公平锁（Nonfair） </p>
<p>加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待 </p>
<ol>
<li>非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个队列 </li>
<li>Java 中的 synchronized 是非公平锁，ReentrantLock 默认的 lock()方法采用的是非公平锁。</li>
</ol>
<h2 id="共享锁和独占锁-java"><a href="#共享锁和独占锁-java" class="headerlink" title="共享锁和独占锁 java"></a>共享锁和独占锁 java</h2><p>并发包提供的加锁模式分为独占锁和共享锁。</p>
<p>独占锁 </p>
<p>独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。独占锁是一种悲观保守的加锁策略，它避免了读&#x2F;读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。</p>
<p>共享锁 </p>
<p>共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。</p>
<ol>
<li><p>AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等待线程的锁获取模式。 </p>
</li>
<li><p>java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，或者被一个 写操作访问，但两者不能同时进行。</p>
</li>
</ol>
<h2 id="重量级锁（Mutex-Lock）"><a href="#重量级锁（Mutex-Lock）" class="headerlink" title="重量级锁（Mutex Lock）"></a>重量级锁（<strong>Mutex Lock</strong>）</h2><p>Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么 Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为</p>
<p>“重量级锁”。JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。</p>
<p>JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和</p>
<p>“偏向锁”。 </p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。 </p>
<p>锁升级 </p>
<p>随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。</p>
<p>“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。 </p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。 </p>
<h2 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h2><p>分段锁也并非一种实际的锁，而是一种思想 ConcurrentHashMap 是学习分段锁的最好实践</p>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><h3 id="减少锁持有时间"><a href="#减少锁持有时间" class="headerlink" title="减少锁持有时间"></a>减少锁持有时间</h3><p>只用在有线程安全要求的程序上加锁 </p>
<h3 id="减小锁粒度"><a href="#减小锁粒度" class="headerlink" title="减小锁粒度"></a>减小锁粒度</h3><p>将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。</p>
<p>降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是</p>
<p>ConcurrentHashMap。 </p>
<h3 id="锁分离"><a href="#锁分离" class="headerlink" title="锁分离"></a>锁分离</h3><p>最常见的锁分离就是读写锁 ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能，具体也请查看[高并发 Java 五【图灵、马士兵、慕课网、极客时间等更多架构师课程，请加微信642620018】] </p>
<p>JDK 并发包 1。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如</p>
<p>LinkedBlockingQueue 从头部取出，从尾部放数据。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。 </p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作，多数是因为程序员编码不规范引起。</p>
<h2 id="Synchronized-同步锁"><a href="#Synchronized-同步锁" class="headerlink" title="Synchronized 同步锁"></a>Synchronized 同步锁</h2><p>synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重入锁。 </p>
<h3 id="Synchronized作用范围"><a href="#Synchronized作用范围" class="headerlink" title="Synchronized作用范围"></a>Synchronized作用范围</h3><ol>
<li><p>作用于方法时，锁住的是对象的实例(this)； </p>
</li>
<li><p>当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen</p>
</li>
</ol>
<p>（jdk1.8 则是 metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程； </p>
<ol start="3">
<li>synchronized 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列，</li>
</ol>
<p>当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。 </p>
<h3 id="Synchronized核心组件"><a href="#Synchronized核心组件" class="headerlink" title="Synchronized核心组件"></a>Synchronized核心组件</h3><ol>
<li><p>Wait Set：哪些调用 wait 方法被阻塞的线程被放置在这里； </p>
</li>
<li><p>Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中； </p>
</li>
<li><p>Entry List：Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中； </p>
</li>
<li><p>OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为 OnDeck； </p>
</li>
<li><p>Owner：当前已经获取到所资源的线程被称为 Owner； </p>
</li>
<li><p>!Owner：当前释放锁的线程。</p>
</li>
</ol>
<h3 id="Synchronized-实现"><a href="#Synchronized-实现" class="headerlink" title="Synchronized 实现"></a>Synchronized 实现</h3><p><img src="/.com//synchronized%E5%AE%9E%E7%8E%B0.png" srcset="/img/loading.gif" lazyload alt="synchronized实现"></p>
<ol>
<li><p>JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList 会被大量的并发线程进行 CAS 访问，为了降低对尾部元素的竞争，JVM 会将一部分线程移动到 EntryList 中作为候选竞争线程。 </p>
</li>
<li><p>Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并指定EntryList 中的某个线程为 OnDeck 线程（一般是最先进去的那个线程）。 </p>
</li>
<li><p>Owner 线程并不直接把锁传递给 OnDeck 线程，而是把锁竞争的权利交给 OnDeck，OnDeck需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在JVM 中，也把这种选择行为称之为“竞争切换”。 </p>
</li>
<li><p>OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 EntryList 中。如果Owner线程被wait方法阻塞，则转移到WaitSet队列中，直到某个时刻通过notify 或者 notifyAll 唤醒，会重新进去 EntryList 中。 </p>
</li>
<li><p>处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux 内核下采用pthread_mutex_lock 内核函数实现的）。 </p>
</li>
<li><p>Synchronized 是非公平锁。 Synchronized 在线程进入 ContentionList 时，等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源。</p>
</li>
<li><p>每个对象都有个 monitor 对象，加锁就是在竞争 monitor 对象，代码块加锁是在前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的</p>
</li>
<li><p>synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。 </p>
</li>
<li><p>Java1.6，synchronized进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。 </p>
</li>
<li><p>锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀； </p>
</li>
<li><p>JDK 1.6 中默认是开启偏向锁和轻量级锁，可以通过-XX:-UseBiasedLocking 来禁用偏向锁。</p>
</li>
</ol>
<h2 id="什么是-AQS（抽象的队列同步器）"><a href="#什么是-AQS（抽象的队列同步器）" class="headerlink" title="什么是 AQS（抽象的队列同步器）"></a>什么是 <strong>AQS</strong>（<strong>抽象的队列同步器</strong>）</h2><p>AbstractQueuedSynchronizer 类如其名，抽象的队列式的同步器，AQS 定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock&#x2F;Semaphore&#x2F;CountDownLatch。 </p>
<p><img src="/.com//AQS%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt="AQS结构"></p>
<p>它维护了一个 volatile int state（代表共享资源）和一个 FIFO 线程等待队列（多线程争用资源被阻塞时会进入此队列）。state 的访问方式有三种: getState()、 setState() 、compareAndSetState() 。</p>
<p>AQS 定义两种资源共享方式 </p>
<p>Exclusive独占资源-ReentrantLock</p>
<p>Exclusive（独占，只有一个线程能执行，如 ReentrantLock） </p>
<p>Share共享资源-Semaphore&#x2F;CountDownLatch</p>
<p>Share（共享，多个线程可同时执行，如 Semaphore&#x2F;CountDownLatch）。</p>
<p>AQS只是一个框架，具体资源的获取&#x2F;释放方式交由自定义同步器去实现，AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get&#x2F;set&#x2F;CAS)之所以没有定义成 abstract，是因为独占模式下只用实现 tryAcquire-tryRelease，而共享模式下只用实现 tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F; 唤醒出队等），AQS 已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法： </p>
<p>1． isHeldExclusively()：该线程是否正在独占资源。只有用到 condition 才需要去实现它。 </p>
<p>2． tryAcquire(int)：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。 </p>
<p>3． tryRelease(int)：独占方式。尝试释放资源，成功则返回 true，失败则返回 false。 </p>
<p>4． tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 </p>
<p>5． tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回 true，否则返回 false。 </p>
<p>同步器的实现是ABS核心（state资源状态计数） </p>
<p>同步器的实现是 ABS 核心，以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到A线程unlock()到state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。 </p>
<p>以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state 会 CAS 减1。等到所有子线程都执行完后(即state&#x3D;0)，会 unpark()主调用线程，然后主调用线程就会从 await()函数返回，继续后余动作。 </p>
<p>ReentrantReadWriteLock 实现独占和共享两种方式 </p>
<p> 一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现 tryAcquiretryRelease、tryAcquireShared-tryReleaseShared 中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如 ReentrantReadWriteLock。 </p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p> ReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。 </p>
<p>Lock接口的主要方法 </p>
<ol>
<li><p>void lock(): 执行此方法时, 如果锁处于空闲状态, 当前线程将获取到锁. 相反, 如果锁已经被其他线程持有, 将禁用当前线程, 直到当前线程获取到锁. </p>
</li>
<li><p>boolean tryLock()：如果锁可用, 则获取锁, 并立即返回 true, 否则返回 false. 该方法和 lock()的区别在于, tryLock()只是”试图”获取锁, 如果锁不可用, 不会导致当前线程被禁用, 当前线程仍然继续往下执行代码. 而 lock()方法则是一定要获取到锁, 如果锁不可用, 就一直等待, 在未获得锁之前,当前线程并不继续向下执行. </p>
</li>
<li><p>void unlock()：执行此方法时, 当前线程将释放持有的锁. 锁只能由持有者释放, 如果线程并不持有锁, 却执行该方法, 可能导致异常的发生.</p>
</li>
<li><p>Condition newCondition()：条件对象，获取等待通知组件。该组件和当前的锁绑定，</p>
</li>
</ol>
<p>当前线程只有获取了锁，才能调用该组件的 await()方法，而调用后，当前线程将缩放锁。</p>
<ol start="5">
<li><p>getHoldCount() ：查询当前线程保持此锁的次数，也就是执行此线程执行lock方法的次数。 </p>
</li>
<li><p>getQueueLength（）：返回正等待获取此锁的线程估计数，比如启动 10 个线程，1 个线程获得锁，此时返回的是 9 </p>
</li>
<li><p>getWaitQueueLength：（Condition condition）返回等待与此锁相关的给定条件的线程估计数。比如 10 个线程，用同一个 condition 对象，并且此时这 10 个线程都执行了 condition 对象的 await 方法，那么此时执行此方法返回 10 </p>
</li>
<li><p>hasWaiters(Condition condition)：查询是否有线程等待与此锁有关的给定条件</p>
</li>
</ol>
<p>(condition)，对于指定 contidion 对象，有多少线程执行了 condition.await 方法 </p>
<ol start="9">
<li><p>hasQueuedThread(Thread thread)：查询给定线程是否等待获取此锁 </p>
</li>
<li><p>hasQueuedThreads()：是否有线程等待此锁</p>
</li>
<li><p>isFair()：该锁是否公平锁</p>
</li>
<li><p>isHeldByCurrentThread()： 当前线程是否保持锁锁定，线程的执行 lock 方法的前后分别是 false 和 true </p>
</li>
<li><p>isLock()：此锁是否有任意线程占用</p>
</li>
<li><p>lockInterruptibly（）：如果当前线程未被中断，获取锁</p>
</li>
<li><p>tryLock（）：尝试获得锁，仅在调用时锁未被线程占用，获得锁</p>
</li>
<li><p>tryLock(long timeout TimeUnit unit)：如果锁在给定等待时间内没有被另一个线程保持，则获取该锁。</p>
</li>
</ol>
<h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><p>JVM 按随机、就近原则分配锁的机制则称为不公平锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式，默认为非公平锁。非公平锁实际执行的效率要远远超出公平锁，除非程序有特殊需要，否则最常用非公平锁的分配机制。</p>
<h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁，</p>
<p>ReentrantLock 在构造函数中提供了是否公平锁的初始化方式来定义公平锁。 </p>
<h3 id="ReentrantLock与synchronized"><a href="#ReentrantLock与synchronized" class="headerlink" title="ReentrantLock与synchronized"></a>ReentrantLock与synchronized</h3><ol>
<li><p>ReentrantLock 通过方法 lock()与 unlock()来进行加锁与解锁操作，与 synchronized 会被 JVM 自动解锁机制不同，ReentrantLock 加锁后需要手动进行解锁。为了避免程序出现异常而无法正常解锁的情况，使用 ReentrantLock 必须在 finally 控制块中进行解锁操作。</p>
</li>
<li><p>ReentrantLock 相比 synchronized 的优势是可中断、公平锁、多个锁。这种情况下需要使用 ReentrantLock。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        <span class="hljs-comment">// Lock lock=new ReentrantLock(true);//公平锁</span><br>        <span class="hljs-comment">// Lock lock=new ReentrantLock(false);//非公平锁</span><br>        <span class="hljs-comment">//Condition condition = lock.newCondition();</span><br>        <span class="hljs-comment">// 创建 Condition     public void testMethod() &#123;</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            lock.lock();<span class="hljs-comment">//lock 加锁</span><br>            <span class="hljs-comment">//1：wait 方法等待：</span><br>            <span class="hljs-comment">//System.out.println(&quot;开始 wait&quot;);</span><br>            <span class="hljs-comment">// condition.await();</span><br>            <span class="hljs-comment">//通过创建 Condition 对象来使线程 wait，必须先执行 lock.lock 方法获得锁</span><br>            <span class="hljs-comment">//:2：signal 方法唤醒</span><br>            <span class="hljs-comment">//condition.signal();//condition 对象的 signal 方法可以唤醒 wait 线程</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                System.out.println(<span class="hljs-string">&quot;ThreadName=&quot;</span> + Thread.currentThread().getName()+ (<span class="hljs-string">&quot; &quot;</span> + (i + <span class="hljs-number">1</span>)));<br>            &#125;<br><span class="hljs-comment">//        &#125; catch (InterruptedException e) &#123;</span><br><span class="hljs-comment">//            e.printStackTrace();</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyService</span> <span class="hljs-variable">myService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyService</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    myService.test();<br>                &#125;<br>            &#125;);<br>            thread.start();<br>        &#125;<br>    &#125;<br><br>&#125; <br></code></pre></td></tr></table></figure>

<h3 id="Condition类和Object类锁方法区别区别"><a href="#Condition类和Object类锁方法区别区别" class="headerlink" title="Condition类和Object类锁方法区别区别"></a>Condition类和Object类锁方法区别区别</h3><ol>
<li><p>Condition 类的 awiat 方法和 Object 类的 wait 方法等效 </p>
</li>
<li><p>Condition 类的 signal 方法和 Object 类的 notify 方法等效 </p>
</li>
<li><p>Condition 类的 signalAll 方法和 Object 类的 notifyAll 方法等效 </p>
</li>
<li><p>ReentrantLock 类可以唤醒指定条件的线程，而 object 的唤醒是随机的</p>
</li>
</ol>
<h3 id="tryLock和lock和lockInterruptibly的区别"><a href="#tryLock和lock和lockInterruptibly的区别" class="headerlink" title="tryLock和lock和lockInterruptibly的区别"></a>tryLock和lock和lockInterruptibly的区别</h3><ol>
<li>tryLock 能获得锁就返回 true，不能就立即返回 false，tryLock(long timeout,TimeUnit unit)，可以增加时间限制，如果超过该时间段还没获得锁，返回 false </li>
<li>lock 能获得锁就返回 true，不能的话一直等待获得锁 </li>
<li>lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程， lock 不会抛出异常，而 lockInterruptibly 会抛出异常。</li>
</ol>
<h2 id="synchronized和-ReentrantLock-的区别"><a href="#synchronized和-ReentrantLock-的区别" class="headerlink" title="synchronized和 ReentrantLock 的区别"></a>synchronized和 <strong>ReentrantLock</strong> 的区别</h2><p>两者的共同点：</p>
<ol>
<li><p>都是用来协调多线程对共享对象、变量的访问</p>
</li>
<li><p>都是可重入锁，同一线程可以多次获得同一个锁</p>
</li>
<li><p>都保证了可见性和互斥性</p>
</li>
</ol>
<p>两者的不同点：</p>
<ol>
<li><p>ReentrantLock 显示的获得、释放锁，synchronized 隐式获得释放锁 </p>
</li>
<li><p>ReentrantLock 可响应中断、可轮回，synchronized 是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性 </p>
</li>
<li><p>ReentrantLock 是 API 级别的，synchronized 是 JVM 级别的 </p>
</li>
<li><p>ReentrantLock 可以实现公平锁</p>
</li>
<li><p>ReentrantLock 通过 Condition 可以绑定多个条件 </p>
</li>
<li><p>底层实现不一样， synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻塞，采用的是乐观并发策略 </p>
</li>
<li><p>Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现。 </p>
</li>
<li><p>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁。 </p>
</li>
<li><p>Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断。 </p>
</li>
<li><p>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</p>
</li>
<li><p>Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等。</p>
</li>
</ol>
<h2 id="ReadWriteLock读写锁"><a href="#ReadWriteLock读写锁" class="headerlink" title="ReadWriteLock读写锁"></a>ReadWriteLock读写锁</h2><p>为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。 </p>
<p>读锁 </p>
<p>如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁 </p>
<p>写锁 </p>
<p>如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！ </p>
<p>Java 中 读 写 锁 有 个 接 口 java.util.concurrent.locks.ReadWriteLock ， 也 有 具 体 的 实 现ReentrantReadWriteLock。 </p>
<h2 id="Semaphore信号量"><a href="#Semaphore信号量" class="headerlink" title="Semaphore信号量"></a>Semaphore信号量</h2><p> Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore 可以用来构建一些对象池，资源池之类的，比如数据库连接池实现互斥锁（计数器为1） </p>
<p>我们也可以创建计数为 1 的 Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。 </p>
<p>代码实现它的用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">	<span class="hljs-comment">// 创建一个计数阈值为 5 的信号量对象 </span><br> 	<span class="hljs-comment">// 只能 5 个线程同时访问 </span><br> 	<span class="hljs-type">Semaphore</span> <span class="hljs-variable">semp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">5</span>); <br> 	<span class="hljs-keyword">try</span> &#123; <br> 	 	<span class="hljs-comment">// 申请许可  	 	 	</span><br>    semp.acquire(); <br> 	 	 <span class="hljs-comment">// 业务逻辑 </span><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123; <br> 	&#125; <span class="hljs-keyword">finally</span> &#123; <br> 	 	 	<span class="hljs-comment">// 释放许可 </span><br> 	 	 	semp.release(); <br> 	&#125; <br></code></pre></td></tr></table></figure>

<p>Semaphore 与ReentrantLock</p>
<p>Semaphore 基本能完成 ReentrantLock 的所有工作，使用方法也与之类似，通过 acquire()与 release()方法来获得和释放临界资源。经实测，Semaphone.acquire()方法默认为可响应中断锁，与 ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被Thread.interrupt()方法中断。</p>
<p>此外，Semaphore 也实现了可轮询的锁请求与定时锁的功能，除了方法名 tryAcquire 与 tryLock 不同，其使用方法与ReentrantLock几乎一致。Semaphore也提供了公平与非公平锁的机制，也可在构造函数中进行设定。</p>
<p>Semaphore的锁释放操作也由手动进行，因此与ReentrantLock 一样，为避免线程因抛出异常而无法正常释放锁的情况发生，释放锁的操作也必须在 finally 代码块中完成。 </p>
<h3 id="Semaphore-类中比较重要的几个方法："><a href="#Semaphore-类中比较重要的几个方法：" class="headerlink" title="Semaphore 类中比较重要的几个方法："></a>Semaphore 类中比较重要的几个方法：</h3><ol>
<li><p>public void acquire(): 用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。 </p>
</li>
<li><p>public void acquire(int permits):获取 permits 个许可 </p>
</li>
<li><p>public void release() { } :释放许可。注意，在释放许可之前，必须先获获得许可。 </p>
</li>
<li><p>public void release(int permits) { }:释放 permits 个许可</p>
</li>
</ol>
<p>上面 4 个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法</p>
<ol>
<li><p>public boolean tryAcquire():尝试获取一个许可，若获取成功，则立即返回 true，若获取失败，则立即返回 false </p>
</li>
<li><p>public boolean tryAcquire(long timeout, TimeUnit unit):尝试获取一个许可，若在指定的时间内获取成功，则立即返回 true，否则则立即返回 false </p>
</li>
<li><p>public boolean tryAcquire(int permits):尝试获取 permits 个许可，若获取成功，则立即返回 true，若获取失败，则立即返回 false </p>
</li>
<li><p>public boolean tryAcquire(int permits, long timeout, TimeUnit unit): 尝试获取 permits 个许可，若在指定的时间内获取成功，则立即返回 true，否则则立即返回 false </p>
</li>
<li><p>还可以通过 availablePermits()方法得到可用的许可数目。</p>
</li>
</ol>
<h2 id="CyclicBarrier、CountDownLatch的用法"><a href="#CyclicBarrier、CountDownLatch的用法" class="headerlink" title="CyclicBarrier、CountDownLatch的用法"></a>CyclicBarrier、CountDownLatch的用法</h2><p>CountDownLatch（线程计数器 ）</p>
<p>CountDownLatch类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务 A，它要等待其他 4 个任务执行完毕之后才能执行，此时就可以利用 CountDownLatch 来实现这种功能了。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">2</span>);           <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; <br>        System.out.println(<span class="hljs-string">&quot;子线程&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot;正在执行&quot;</span>); <br>        Thread.sleep(<span class="hljs-number">3000</span>); <br>        System.out.println(<span class="hljs-string">&quot;子线程&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot;执行完毕&quot;</span>); <br>        latch.countDown(); <br>      &#125;<br>    &#125;.start(); <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123; <br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; <br>        System.out.println(<span class="hljs-string">&quot;子线程&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot;正在执行&quot;</span>); <br>        Thread.sleep(<span class="hljs-number">3000</span>); <br>        System.out.println(<span class="hljs-string">&quot;子线程&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot;执行完毕&quot;</span>); <br>        latch.countDown(); <br>     &#125;<br>    &#125;.start();   <br>    System.out.println(<span class="hljs-string">&quot;等待 2 个子线程执行完毕...&quot;</span>); <br>    latch.await(); <br>    System.out.println(<span class="hljs-string">&quot;2 个子线程已经执行完毕&quot;</span>); <br>    System.out.println(<span class="hljs-string">&quot;继续执行主线程&quot;</span>); <br>&#125; <br></code></pre></td></tr></table></figure>

<p> CyclicBarrier（回环栅栏-等待至 barrier 状态再全部同时执行）</p>
<p>字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier 可以被重用。我们暂且把这个状态就叫做 barrier，当调用 await()方法之后，线程就处于 barrier 了。 </p>
<p>CyclicBarrier 中最重要的方法就是 await 方法，它有 2 个重载版本： </p>
<ol>
<li><p>public int await()：用来挂起当前线程，直至所有线程都到达 barrier 状态再同时执行后续任务；</p>
</li>
<li><p>public int await(long timeout, TimeUnit unit)：让这些线程等待至一定的时间，如果还有线程没有到达 barrier 状态就直接让到达 barrier 的线程执行后续任务。</p>
</li>
</ol>
<p>具体使用如下，另外 CyclicBarrier 是可以重用的。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>       <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">barrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(N);<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Writer</span>(barrier).start();<br>   &#125;<br><br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Writer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>       <span class="hljs-keyword">private</span> CyclicBarrier cyclicBarrier;<br><br>       <span class="hljs-keyword">public</span> <span class="hljs-title function_">Writer</span><span class="hljs-params">(CyclicBarrier cyclicBarrier)</span> &#123;<br>           <span class="hljs-built_in">this</span>.cyclicBarrier = cyclicBarrier;<br>       &#125;<br><br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>               Thread.sleep(<span class="hljs-number">5000</span>);      <span class="hljs-comment">//以睡眠来模拟线程需要预定写入数据操作 System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;写入数据完毕，等待其他线程写入完毕&quot;);</span><br>               cyclicBarrier.await();<br>           &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>               e.printStackTrace();<br>           &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;<br>               e.printStackTrace();<br>           &#125;<br>           System.out.println(<span class="hljs-string">&quot;所有线程写入完毕，继续处理其他任务，比如数据操作&quot;</span>);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h2 id="ConcurrentHashMap-并发集合"><a href="#ConcurrentHashMap-并发集合" class="headerlink" title="ConcurrentHashMap 并发集合"></a>ConcurrentHashMap 并发集合</h2><h3 id="减小锁粒度-1"><a href="#减小锁粒度-1" class="headerlink" title="减小锁粒度"></a>减小锁粒度</h3><p>减小锁粒度是指缩小锁定对象的范围，从而减小锁冲突的可能性，从而提高系统的并发能力。减小锁粒度是一种削弱多线程锁竞争的有效手段，这种技术典型的应用是 ConcurrentHashMap(高性能的 HashMap)类的实现。对于 HashMap 而言，最重要的两个方法是 get 与 set 方法，如果我们对整个 HashMap 加锁，可以得到线程安全的对象，但是加锁粒度太大。Segment 的大小也被称为 ConcurrentHashMap 的并发度。 </p>
<h3 id="ConcurrentHashMap分段锁"><a href="#ConcurrentHashMap分段锁" class="headerlink" title="ConcurrentHashMap分段锁"></a>ConcurrentHashMap分段锁</h3><p>ConcurrentHashMap，它内部细分了若干个小的 HashMap，称之为段(Segment)。默认情况下一个 ConcurrentHashMap 被进一步细分为 16 个段，既就是锁的并发度。 </p>
<p>如果需要在 ConcurrentHashMap 中添加一个新的表项，并不是将整个 HashMap 加锁，而是首先根据hashcode得到该表项应该存放在哪个段中，然后对该段加锁，并完成put操作。在多线程环境中，如果多个线程同时进行put操作，只要被加入的表项不存放在同一个段中，则线程间可以做到真正的并行。 </p>
<p>ConcurrentHashMap 是由Segment数组结构和HashEntry数组结构组成 </p>
<p>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。Segment 是一种可重入锁 ReentrantLock，在 ConcurrentHashMap 里扮演锁的角色，HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 的结构和 HashMap 类似，是一种数组和链表结构， 一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素， 每个 Segment 守护一个 HashEntry 数组里的元素,当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁。 </p>
<h2 id="什么是CAS（比较并交换-乐观锁机制-锁自旋）"><a href="#什么是CAS（比较并交换-乐观锁机制-锁自旋）" class="headerlink" title="什么是CAS（比较并交换-乐观锁机制-锁自旋）"></a>什么是CAS（比较并交换-乐观锁机制-锁自旋）</h2><h3 id="概念及特性"><a href="#概念及特性" class="headerlink" title="概念及特性"></a>概念及特性</h3><p>CAS（Compare And Swap&#x2F;Set）比较并交换，CAS过程是这样：它包含 3 个参数 CAS(V,E,N)。V 表示要更新的变量(内存值)，E 表示预期值(旧的)，N 表示新值。当且仅当 V 值等于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS 返回当前 V 的真实值。 </p>
<p>CAS 操作是抱着乐观的态度进行的(乐观锁)，它总是认为自己可以成功完成操作。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，</p>
<p>CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。 </p>
<p>原子包 java.util.concurrent.atomic（锁自旋）</p>
<p>JDK1.5 的原子包：java.util.concurrent.atomic 这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等</p>
<p>到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。</p>
<p>相对于对于 synchronized 这种阻塞算法，CAS 是非阻塞算法的一种常见实现。由于一般 CPU 切换时间比 CPU 指令集操作更加长， 所以 J.U.C 在性能上有了很大的提升。如下代码： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicInteger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;   <br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value;  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;           <br>        <span class="hljs-keyword">return</span> value;   <br>     &#125;   <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span> &#123;   <br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-comment">//CAS 自旋，一直尝试，直达成功 </span><br>           <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> get();           <br>           <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current + <span class="hljs-number">1</span>;          <br>           <span class="hljs-keyword">if</span> (compareAndSet(current, next))   <span class="hljs-keyword">return</span> current;   <br>        &#125;   <br>    &#125;   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> &#123;         <br>    <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, valueOffset, expect, update);   <br>    &#125;   <br>&#125; <br></code></pre></td></tr></table></figure>

<p>getAndIncrement 采用了 CAS 操作，每次从内存中读取数据然后将此数据和+1 后的结果进行 CAS 操作，如果成功就返回结果，否则重试直到成功为止。而 compareAndSet 利用 JNI 来完成。</p>
<p>CPU 指令的操作：</p>
<p><img src="/.com//CAS%E6%8C%87%E4%BB%A4.png" srcset="/img/loading.gif" lazyload alt="CAS指令"></p>
<h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>CAS 会导致“ABA 问题”。CAS 算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。 </p>
<p>比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但是不代表这个过程就是没有问题的。 </p>
<p>部分乐观锁的实现是通过版本号（version）的方式来解决 ABA 问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题，因为版本号只会增加不会减少。</p>
<h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><p>首先说明，此处 AtomicInteger，一个提供原子操作的 Integer 的类，常见的还有AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference 等，他们的实现原理相同，区别在与运算对象类型的不同。令人兴奋地，还可以通过 AtomicReference<V>将一个对象的所有操作转化成原子操作。 </V></p>
<p>我们知道，在多线程程序中，诸如++i 或 i++等运算不具有原子性，是不安全的线程操作之一。通常我们会使用 synchronized 将该操作变成一个原子操作，但 JVM 为此类操作特意提供了一些同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常AtomicInteger 的性能是 ReentantLock 的好几倍。 </p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/java/">java</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/java/">java</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/07/11/java/java%E9%9B%86%E5%90%88/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">java集合</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/06/30/spring_cloud/spring_cloud_config%E5%AE%9E%E8%B7%B5/">
                        <span class="hidden-mobile">spring_boot_config实践</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        京ICP备18028493号
      </a>
    </span>
    
      
        <span>
          <a
            href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010502035713"
            rel="nofollow noopener"
            class="beian-police"
            target="_blank"
          >
            
              <span style="visibility: hidden; width: 0">|</span>
              <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
            
            <span>11010502035713</span>
          </a>
        </span>
      
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
